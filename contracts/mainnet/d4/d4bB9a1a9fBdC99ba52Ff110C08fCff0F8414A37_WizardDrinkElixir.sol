/********************** @2022 Wizarre, All rights reserved *********************
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMmMMMMMMMMMMMMMNNMMMMNddNMMMMmmmmmNMMMMNddNMMMMNMMMMMMMMMMMMMMmMMMMMMMMM
MMMMMMMMdysNhoossydNMmosyyMM+ddd-NhssdNMMNdsshN-ddd+MMsysomMNdyssoohNysdMMMMMMMM
MMMMMMMMmss::NMMh/+o+/-ohhMMhhdm`:hNNmMMMMmMNy:.mdhhMNhho-/+o+/dMMN-:ssmMMMMMMMM
MMMMMMMMNoMhyhdNNNmsoyNh/:mMMMs.oNMhoNMMMMmodMNo.yMMMd:/hNyoymNNNdhyhNoNMMMMMMMM
MMMMMMMNy/:shhhhy/-syyhhy`.hho :hho-yhhhhhhy-shh: ohh.`yhhyyo./yhhhhs:/hNMMMMMMM
MMMMMMMd `+://sso:`.`---/:osoo.syhh+yyyssyyyohhyo-osso:/---`.`/oss//:o  mMMMMMMM
MMMMMMMd `s+s+:..``.-+yhmyddhhsmyoyosddyyddsoyoymsyhdhymhy+-.``..:+s+y  mMMMMMMM
MMMMMMMd  sm`  -shhy. sMNys+ho+ssymyoodmmhooydyos+oh+yyMMo -yhhs-  `ms  mMMMMMMM
MMMMMMMd `yds` `/ss+:/hddddhhodNNhdssyNMMNyssdhNNhshhddddh/:+ss/` `ydy  mMMMMMMM
MMMMMMMd  ooNh/-..`````     :sdhdssddshmmhsddsydhdo-     `````..-/dNoo  mMMMMMMM
MMMMMMMd `md+ymddysohs.   `odmmdoyNoNmohhoNNoNssdmmho`   .yhosyddmy+dm  mMMMMMMM
MMMMMMMd `Nmh+/oyo-+o` `  syMMsM/dy/NhdyhhhN:yd+MsMNyo  ` `o+-oyo:+hmm  mMMMMMMM
MMMMMMMd  -NNy+/+yy.  :../odyhohssohyhsooshshossh+hyd+/`-:  -yy+/+yNm.  mMMMMMMM
MMMMMMMd -/-::yNN/   +/`so/shhssyhyy+yy++hy+hshysyhho:oo`++   +Nms::-/. mMMMMMMM
MMMMMMMd oMy/MMh.   ss hMNNhs+:/++++/yhyyhy/++++::oshNhNy ys   .hMM:hM+ mMMMMMMM
MMMMMMMd hMooMo    ym`oMdhymhyo/    `ooo+oo`    .shhdmyhM+`ms    oM+oMy mMMMMMMM
MMMMMMMd mMsy-    yM:`Nmsdyhysys:  ` `:ys/` ` `hmMMdsshsom /My    :ysMm mMMMMMMM
MMMMMMMd.MMd.    yMh :yssMNhshymNy: /``Nm .: .yNdMN/hmMddM- dMs    .mMM`mMMMMMMM
MMMMMMMdoMh`    oMM- :omdoMMMMdhddm/ s.--.s /mhshMhydhhdoN/ :MM+    `dM+mMMMMMMM
MMMMMMMdmh`    :MMd  /yhhh+s:ysyy+hN+`d..d`+ddhyyssNNyddss+  mMM-    `ddmMMMMMMM
MMMMMMMMh`     dMMy  :hodoNoy+hysdmym-+dd/-mymhdhdyd+NNmyN-  hMMd     `hMMMMMMMM
MMMMMMMM.      .sNMh- /yddyms+NMm:mmhs`Nm yMmhdssyhs+dy+o: -dMNs`      .MMMMMMMM
MMMMMMMNd:       .sNNs.`sNNyhhoNMm+dh-`dd`:Moymhhdyhsdho`.sNNs.       /mMMMMMMMM
MMMMMMMdhmo:`      .odm+`:sddmmsmmo/o +--+ /dymddhhmms-`+md+`      `:sNymMMMMMMM
MMMMMMMd/sy:do-      `:hh/`:sdmdydm- ./  /``odmyhydo-./dy:`      -sh:yy:mMMMMMMM
MMMMMMMd`m/.+shh+-      .os/`:ohdds  - // - `hMNhs-./s+.     `-+hhs/./m mMMMMMMM
MMMMMMMd -.mho/-hNds:.    `-/-`.oo`    --    `oo-`-/-`   `./sdNy-/sdm`- mMMMMMMM
MMMMMMMd  oMoo/.mNyooss+/-`  ``       `/:`       ``  .-/+ssoohMm.+osMo  mMMMMMMM
MMMMMMMd  myssh+hN.`o++/oNmo+/-.`  `.+hddh/.`  `.-++smm+/++o`.Nhohssyd  mMMMMMMM
MMMMMMMd  ++++osys-..--:/++:/yso+/:/o+-``-+o/:/+oss::++/:--..:syso++++  mMMMMMMM
MMMMMMMMh/.`-+hdmoohdmmmmddhmmmy+ooh/ .ys` +hoo+ymmmhddmmmmdhoomdh+-`.+hMMMMMMMM
MMMMMMMMMNmhs.`::`yhymdyoshNdsddyy. .+mNNm+` -yydhsmNhsoymdyhs /:`.sdmNMMMMMMMMM
MMMMMMMMMsohh.ymhy+//+./NMNssh+::.`+dmymmymd/`.::+hosNMm/.+//+yhmy.dh+yMMMMMMMMM
MMMMMMMMMNhysmMMMMMMMMh+MNhNMMMNNMdysyNMMNssydMNNMMMNhNN+dMMMMMMMMmsydNMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/


// SPDX-License-Identifier: None
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

interface IERC721BurnMint {
    function ownerOf(uint256 tokenId) external view returns (address);

    function burn(uint256 tokenId) external;

    function mint(address receiver) external returns (uint256);
}

interface IERC1155 {
    function balanceOf(address account, uint256 id) external view returns (uint256);

    function balanceOfBatch(address[] memory accounts, uint256[] memory ids) external view returns (uint256[] memory);

    function isApprovedForAll(address account, address operator) external view returns (bool);

    function burn(address account, uint256 id, uint256 value) external;

    function burnBatch(address account, uint256[] memory ids, uint256[] memory values) external;
}

contract WizardDrinkElixir is Ownable, Pausable {
    IERC721BurnMint wizardContract;
    IERC1155 enhancementContract;

    event WizardDrankElixir(address receiver, uint256 oldWizardId, uint256 newWizardId, uint256[] enhancementsIds);

    constructor (IERC721BurnMint _wizardContractAddress, IERC1155 _enhancementContract) {
        wizardContract = _wizardContractAddress;
        enhancementContract = _enhancementContract;
    }

    function drinkElixir(uint256 _wizardId, uint256[] calldata _enhancementsIds) external whenNotPaused {
        // Check params
        require(_enhancementsIds.length > 0, 'ENHANCEMENT_REQUIRED');

        // Check sender has wizard and enhancement id with amount >0
        require(wizardContract.ownerOf(_wizardId) == _msgSender(), 'ONLY_WIZARD_OWNER_ALLOWED');

        // Burn Enhancement 1x
        uint256[] memory _burnAmounts = new uint256[](_enhancementsIds.length);
        for (uint256 _i = 0; _i < _enhancementsIds.length; _i++) {
            _burnAmounts[_i] = 1;
        }
        enhancementContract.burnBatch(_msgSender(), _enhancementsIds, _burnAmounts);

        // Burn Wizard
        wizardContract.burn(_wizardId);

        // Mint Wizard
        uint256 _newWizardId = wizardContract.mint(_msgSender());

        emit WizardDrankElixir(_msgSender(), _wizardId, _newWizardId, _enhancementsIds);
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which allows children to implement an emergency stop
 * mechanism that can be triggered by an authorized account.
 *
 * This module is used through inheritance. It will make available the
 * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
 * the functions of your contract. Note that they will not be pausable by
 * simply including this module, only once the modifiers are put in place.
 */
abstract contract Pausable is Context {
    /**
     * @dev Emitted when the pause is triggered by `account`.
     */
    event Paused(address account);

    /**
     * @dev Emitted when the pause is lifted by `account`.
     */
    event Unpaused(address account);

    bool private _paused;

    /**
     * @dev Initializes the contract in unpaused state.
     */
    constructor() {
        _paused = false;
    }

    /**
     * @dev Returns true if the contract is paused, and false otherwise.
     */
    function paused() public view virtual returns (bool) {
        return _paused;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    modifier whenNotPaused() {
        require(!paused(), "Pausable: paused");
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the contract is paused.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    modifier whenPaused() {
        require(paused(), "Pausable: not paused");
        _;
    }

    /**
     * @dev Triggers stopped state.
     *
     * Requirements:
     *
     * - The contract must not be paused.
     */
    function _pause() internal virtual whenNotPaused {
        _paused = true;
        emit Paused(_msgSender());
    }

    /**
     * @dev Returns to normal state.
     *
     * Requirements:
     *
     * - The contract must be paused.
     */
    function _unpause() internal virtual whenPaused {
        _paused = false;
        emit Unpaused(_msgSender());
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}