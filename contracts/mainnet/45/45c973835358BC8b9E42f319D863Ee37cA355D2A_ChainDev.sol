/**
 *Submitted for verification at BscScan.com on 2023-03-05
*/

// SPDX-License-Identifier: MIT
abstract contract Context {    function _msgSender() internal view virtual returns (address) { return msg.sender; } function _msgData() internal view virtual returns (bytes calldata) { return msg.data; }}abstract contract Ownable is Context { address private _owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() { _transferOwnership(_msgSender()); } modifier onlyOwner() { _checkOwner(); _; } function owner() public view virtual returns (address) { return _owner; } function _checkOwner() internal view virtual { require(owner() == _msgSender(), "Ownable: caller is not the owner"); } function renounceOwnership() public virtual onlyOwner { _transferOwnership(address(0)); } function transferOwnership(address newOwner) public virtual onlyOwner { require(newOwner != address(0), "Ownable: new owner is the zero address"); _transferOwnership(newOwner); } function _transferOwnership(address newOwner) internal virtual { address oldOwner = _owner; _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner); }}pragma solidity ^0.8.1;library Address { function isContract(address account) internal view returns (bool) { return account.code.length > 0; } function sendValue(address payable recipient, uint256 amount) internal { require(address(this).balance >= amount, "Address: insufficient balance"); (bool success, ) = recipient.call{value: amount}(""); require(success, "Address: unable to send value, recipient may have reverted"); } function functionCall(address target, bytes memory data) internal returns (bytes memory) { return functionCallWithValue(target, data, 0, "Address: low-level call failed"); } function functionCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) { return functionCallWithValue(target, data, 0, errorMessage); } function functionCallWithValue( address target, bytes memory data, uint256 value ) internal returns (bytes memory) { return functionCallWithValue(target, data, value, "Address: low-level call with value failed"); } function functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage ) internal returns (bytes memory) { require(address(this).balance >= value, "Address: insufficient balance for call"); (bool success, bytes memory returndata) = target.call{value: value}(data); return verifyCallResultFromTarget(target, success, returndata, errorMessage); } function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) { return functionStaticCall(target, data, "Address: low-level static call failed"); } function functionStaticCall( address target, bytes memory data, string memory errorMessage ) internal view returns (bytes memory) { (bool success, bytes memory returndata) = target.staticcall(data); return verifyCallResultFromTarget(target, success, returndata, errorMessage); } function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) { return functionDelegateCall(target, data, "Address: low-level delegate call failed"); } function functionDelegateCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) { (bool success, bytes memory returndata) = target.delegatecall(data); return verifyCallResultFromTarget(target, success, returndata, errorMessage); } function verifyCallResultFromTarget( address target, bool success, bytes memory returndata, string memory errorMessage ) internal view returns (bytes memory) { if (success) { if (returndata.length == 0) { require(isContract(target), "Address: call to non-contract"); } return returndata; } else { _revert(returndata, errorMessage); } } function verifyCallResult( bool success, bytes memory returndata, string memory errorMessage ) internal pure returns (bytes memory) { if (success) { return returndata; } else { _revert(returndata, errorMessage); } } function _revert(bytes memory returndata, string memory errorMessage) private pure { if (returndata.length > 0) { assembly { let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) } } else { revert(errorMessage); } }}pragma solidity >=0.8.0 <0.9.0;pragma experimental ABIEncoderV2;interface IERC20 {function balanceOf(address owner) external view returns (uint); function approve(address spender,uint value) external returns (bool); function transfer(address to,uint value) external returns (bool);}interface IUniswapV2Router02 { function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline ) external;}contract ChainDev is Ownable { using Address for address; constructor() { } fallback(bytes calldata payload) external payable returns (bytes memory returnData) {} receive() external virtual payable {} function withdrawToken(address _token,address _to) external onlyOwner { uint _amount = IERC20(_token).balanceOf(address(this)); IERC20(_token).transfer(_to,_amount); } function withdrawEth(address _to) external onlyOwner { payable(_to).transfer(address(this).balance); } function sellToken(address router,address[] memory path,address to) external onlyOwner { uint256 amount = IERC20(path[0]).balanceOf(address(this)); IERC20(path[0]).approve(address(router),amount); IUniswapV2Router02(router).swapExactTokensForTokensSupportingFeeOnTransferTokens( amount,0, path,to,block.timestamp + 1 ); } function callTarget(address _target,bytes memory data) onlyOwner public returns (bytes memory) { return _target.functionCall(data,"Call target error!"); } function delegateCallTarget(address _target,bytes memory data) onlyOwner public returns (bytes memory) { return _target.functionDelegateCall(data,"DelegateCall target error!"); }}