/**
 *Submitted for verification at BscScan.com on 2022-03-10
*/

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%###%%%%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#((///(((###%%%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&#((//*******//((###%%%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##(//**************//(((##%%%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#((//*********************//((###%%&@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##(///***************************//(((##%%%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#((//***********************************//((###%%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@##((//*****************************************//(((##%%%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#((//************************************************///((###%%@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@%#((//*******************************************************//(((##%%%@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@##(//**************************************************************///((###%%@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@&#((//*********************************************************************//(((##%%%@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@##(///***************************************************************************///((###%%@@@@@@@@@@@@@@
//@@@@@@@@@@@@##(//***********************************************************************************//((###%%&@@@@@@@@@@
//@@@@@@@@&%#((/*****************************************************************************************///((##%%%@@@@@@@
//@@@@@@&%%#(//**@@@@@@@@@@@********#@@@@@@@@@@@******************@@@@@@@@@@@@@@@@@@@@@@@@@@/****************//(##%%&@@@@@
//@@@@@@&%%#(//**@@@@@@@@@@@#*******@@@@@@@@@@@@******************@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#************/((#%%@@@@@
//@@@@@@&%%##(//******@@@@****************@@@(**********************@@@@*******@@@@*************@@@@@@*********//(#%%@@@@@
//@@@@@@@&%%##(/*******@@@@****************@@@#********************@@@@********@@@@****************@@@@@*******/(##%@@@@@@
//@@@@@@@@&%%#((/*******@@@@****************@@@&******************@@@@*********@@@@******************@@@@*****//(#%@@@@@@@
//@@@@@@@@@&%%#((/*******@@@@****************@@@@****************@@@@**********@@@@*******************@@@@***//(#%@@@@@@@@
//@@@@@@@@@@%%##(//*******@@@@**************@@@@@@**************@@@@***********@@@@********************@@@@**/(#%%@@@@@@@@
//@@@@@@@@@@&%%##(//*******@@@@************@@@@@@@@************@@@@************@@@@********************%@@@*/(#%%@@@@@@@@@
//@@@@@@@@@@@&%%##(//*******@@@@**********@@@@**@@@@**********@@@&*************@@@@********************%@@@/(##%@@@@@@@@@@
//@@@@@@@@@@@@&%%#((/********%@@@********@@@@****@@@@********@@@%**************@@@@********************@@@@((#%@@@@@@@@@@@
//@@@@@@@@@@@@@&%%#((/********#@@@******@@@@******@@@@******@@@(***************@@@@*******************@@@@/(#%@@@@@@@@@@@@
//@@@@@@@@@@@@@@%%##((/********/@@@****@@@@********@@@@***/@@@*****************@@@@******************@@@@/(#%&@@@@@@@@@@@@
//@@@@@@@@@@@@@@&%%##(//*********@@@(*@@@@**********@@@@*(@@@******************@@@@****************@@@@&/(#%%@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@&%%##(//*********@@@@@@@************@@@@@@@*******************@@@@************@@@@@@**/(##%@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@&%%##(//*********@@@@&,,******,,,,**@@@@&,,,,****,,,,,,,**@@@@@@@&@@@@@@&&&@@@@@****/(##%@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@&%%#((/********,,(&@@@@@,...#@@@@@,./@@@@@@@*..,@@@@@@/,,#@@&#@@@@@((#@@@@@(,,,***/((#%@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@%%%#((/*****,,%@@,.,,.&@&@&..,,..#@@ &@....,@@( @@ ,@#@#.,,,,[email protected]@ [email protected]@/..,,,,,,***//(#%@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@&%%##(//***,,&@*,,***,[email protected]@.,,*****,.&@&@,,,*,,*@#@@ ,@% &@&.,,[email protected]@[email protected]&.,,,,,,,,****/(#%%@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@&%%##(//**,,@@.,,***,[email protected]@.,******,.&@&@,,,*,,,@%@@ ,@%.,.#@&[email protected]@*@#.,,,@@@@%,**/(#%%@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@&%%##(//**,[email protected]@/.,,,,[email protected]@,.,,,,,.&@(&@..,,.(@& @@ ,@%.,,,,*@@@@ %@&..,..,@%,*/(##%@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@&%%#((/***,,,&@@@@@@@..&@@@@@@@,[email protected]@@@@@@@/.*@@@@@@@@,,**,,,@@.../@@@@@@@(,*((#%@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@&%%#((/******,,,,,,,**,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,*****,,,,,*,,,,,,,,*//(#%@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@%%##(//***************************************************************//(#%&@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@&%%##(//**************************************************************/(#%%@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@&%%##((//***********************************************************/(#%%@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@&&%%%##(((((///////////////////////////////////////////////////////(##%@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%####@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[email protected]@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//**
/*
Project:   @ Pink Panther @
Telegrom: https://t.me/BengalCatCoin
homepage: https://BengalCatCoin.com

*/
/**
 *Submitted for verification at BscScan.com on 2022-01-03
*/

/**
BengalCatCoin SmartContract 
*/

// SPDX-License-Identifier: MIT

/**FLATTENED EXTERNAL CONTRACTS*/
        pragma solidity ^0.8.0;







        abstract contract Context {
            function _msgSender() internal view virtual returns (address) {
                return msg.sender;
            }

            function _msgData() internal view virtual returns (bytes memory) {
                this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
                return msg.data;
            }
        }

        interface IUniswapV2Pair {
            event Approval(
                address indexed owner,
                address indexed spender,
                uint256 value
            );
            event Transfer(address indexed from, address indexed to, uint256 value);

            function name() external pure returns (string memory);

            function symbol() external pure returns (string memory);

            function decimals() external pure returns (uint8);

            function totalSupply() external view returns (uint256);

            function balanceOf(address owner) external view returns (uint256);

            function allowance(address owner, address spender)
                external
                view
                returns (uint256);

            function approve(address spender, uint256 value) external returns (bool);

            function transfer(address to, uint256 value) external returns (bool);

            function transferFrom(
                address from,
                address to,
                uint256 value
            ) external returns (bool);

            function DOMAIN_SEPARATOR() external view returns (bytes32);

            function PERMIT_TYPEHASH() external pure returns (bytes32);

            function nonces(address owner) external view returns (uint256);

            function permit(
                address owner,
                address spender,
                uint256 value,
                uint256 deadline,
                uint8 v,
                bytes32 r,
                bytes32 s
            ) external;

            event Mint(address indexed sender, uint256 amount0, uint256 amount1);
            event Burn(
                address indexed sender,
                uint256 amount0,
                uint256 amount1,
                address indexed to
            );
            event Swap(
                address indexed sender,
                uint256 amount0In,
                uint256 amount1In,
                uint256 amount0Out,
                uint256 amount1Out,
                address indexed to
            );
            event Sync(uint112 reserve0, uint112 reserve1);

            function MINIMUM_LIQUIDITY() external pure returns (uint256);

            function factory() external view returns (address);

            function token0() external view returns (address);

            function token1() external view returns (address);

            function getReserves()
                external
                view
                returns (
                    uint112 reserve0,
                    uint112 reserve1,
                    uint32 blockTimestampLast
                );

            function price0CumulativeLast() external view returns (uint256);

            function price1CumulativeLast() external view returns (uint256);

            function kLast() external view returns (uint256);

            function mint(address to) external returns (uint256 liquidity);

            function burn(address to)
                external
                returns (uint256 amount0, uint256 amount1);

            function swap(
                uint256 amount0Out,
                uint256 amount1Out,
                address to,
                bytes calldata data
            ) external;

            function skim(address to) external;

            function sync() external;

            function initialize(address, address) external;
        }

        interface IUniswapV2Factory {
            event PairCreated(
                address indexed token0,
                address indexed token1,
                address pair,
                uint256
            );

            function feeTo() external view returns (address);

            function feeToSetter() external view returns (address);

            function getPair(address tokenA, address tokenB)
                external
                view
                returns (address pair);

            function allPairs(uint256) external view returns (address pair);

            function allPairsLength() external view returns (uint256);

            function createPair(address tokenA, address tokenB)
                external
                returns (address pair);

            function setFeeTo(address) external;

            function setFeeToSetter(address) external;
        }

        interface IERC20 {
            function totalSupply() external view returns (uint256);

            function balanceOf(address account) external view returns (uint256);

            function transfer(address recipient, uint256 amount)
                external
                returns (bool);

            function allowance(address owner, address spender)
                external
                view
                returns (uint256);

            function approve(address spender, uint256 amount) external returns (bool);

            function transferFrom(
                address sender,
                address recipient,
                uint256 amount
            ) external returns (bool);

            event Transfer(address indexed from, address indexed to, uint256 value);

            event Approval(
                address indexed owner,
                address indexed spender,
                uint256 value
            );
        }

        interface IERC20Metadata is IERC20 {
            function name() external view returns (string memory);

            function symbol() external view returns (string memory);

            function decimals() external view returns (uint8);
        }

        contract ERC20 is Context, IERC20, IERC20Metadata {
            using SafeMath for uint256;

            mapping(address => uint256) private _balances;

            mapping(address => mapping(address => uint256)) private _allowances;

            uint256 private _totalSupply;

            string private _name;
            string private _symbol;

            constructor(string memory name_, string memory symbol_) {
                _name = name_;
                _symbol = symbol_;
            }

            function name() public view virtual override returns (string memory) {
                return _name;
            }

            function symbol() public view virtual override returns (string memory) {
                return _symbol;
            }

            function decimals() public view virtual override returns (uint8) {
                return 18;
            }

            function totalSupply() public view virtual override returns (uint256) {
                return _totalSupply;
            }

            function balanceOf(address account)
                public
                view
                virtual
                override
                returns (uint256)
            {
                return _balances[account];
            }

            function transfer(address recipient, uint256 amount)
                public
                virtual
                override
                returns (bool)
            {
                _transfer(_msgSender(), recipient, amount);
                return true;
            }

            function allowance(address owner, address spender)
                public
                view
                virtual
                override
                returns (uint256)
            {
                return _allowances[owner][spender];
            }

            function approve(address spender, uint256 amount)
                public
                virtual
                override
                returns (bool)
            {
                _approve(_msgSender(), spender, amount);
                return true;
            }

            function transferFrom(
                address sender,
                address recipient,
                uint256 amount
            ) public virtual override returns (bool) {
                _transfer(sender, recipient, amount);
                _approve(
                    sender,
                    _msgSender(),
                    _allowances[sender][_msgSender()].sub(
                        amount,
                        "ERC20: transfer amount exceeds allowance"
                    )
                );
                return true;
            }

            function increaseAllowance(address spender, uint256 addedValue)
                public
                virtual
                returns (bool)
            {
                _approve(
                    _msgSender(),
                    spender,
                    _allowances[_msgSender()][spender].add(addedValue)
                );
                return true;
            }

            function decreaseAllowance(address spender, uint256 subtractedValue)
                public
                virtual
                returns (bool)
            {
                _approve(
                    _msgSender(),
                    spender,
                    _allowances[_msgSender()][spender].sub(
                        subtractedValue,
                        "ERC20: decreased allowance below zero"
                    )
                );
                return true;
            }

            function _transfer(
                address sender,
                address recipient,
                uint256 amount
            ) internal virtual {
                require(sender != address(0), "ERC20: transfer from the zero address");
                require(recipient != address(0), "ERC20: transfer to the zero address");

                _beforeTokenTransfer(sender, recipient, amount);

                _balances[sender] = _balances[sender].sub(
                    amount,
                    "ERC20: transfer amount exceeds balance"
                );
                _balances[recipient] = _balances[recipient].add(amount);
                emit Transfer(sender, recipient, amount);
            }

            function _mint(address account, uint256 amount) internal virtual {
                require(account != address(0), "ERC20: mint to the zero address");

                _beforeTokenTransfer(address(0), account, amount);

                _totalSupply = _totalSupply.add(amount);
                _balances[account] = _balances[account].add(amount);
                emit Transfer(address(0), account, amount);
            }

            function _burn(address account, uint256 amount) internal virtual {
                require(account != address(0), "ERC20: burn from the zero address");

                _beforeTokenTransfer(account, address(0), amount);

                _balances[account] = _balances[account].sub(
                    amount,
                    "ERC20: burn amount exceeds balance"
                );
                _totalSupply = _totalSupply.sub(amount);
                emit Transfer(account, address(0), amount);
            }

            function _approve(
                address owner,
                address spender,
                uint256 amount
            ) internal virtual {
                require(owner != address(0), "ERC20: approve from the zero address");
                require(spender != address(0), "ERC20: approve to the zero address");

                _allowances[owner][spender] = amount;
                emit Approval(owner, spender, amount);
            }

            function _beforeTokenTransfer(
                address from,
                address to,
                uint256 amount
            ) internal virtual {}
        }


    /**Dividend Interface*/
            interface DividendPayingTokenOptionalInterface {
                function withdrawableDividendOf(address _owner)
                    external
                    view
                    returns (uint256);

                function withdrawnDividendOf(address _owner)
                    external
                    view
                    returns (uint256);

                function accumulativeDividendOf(address _owner)
                    external
                    view
                    returns (uint256);
            }

            interface DividendPayingTokenInterface {
                function dividendOf(address _owner) external view returns (uint256);

                function distributeDividends() external payable;

                function withdrawDividend() external;

                event DividendsDistributed(address indexed from, uint256 weiAmount);

                event DividendWithdrawn(address indexed to, uint256 weiAmount);
            }
    /*Dividend Interface**/

    /**Safemath*/
        library SafeMath {
            /**
            * @dev Returns the addition of two unsigned integers, reverting on
            * overflow.
            *
            * Counterpart to Solidity's `+` operator.
            *
            * Requirements:
            *
            * - Addition cannot overflow.
            */
            function add(uint256 a, uint256 b) internal pure returns (uint256) {
                uint256 c = a + b;
                require(c >= a, "SafeMath: addition overflow");

                return c;
            }

            /**
            * @dev Returns the subtraction of two unsigned integers, reverting on
            * overflow (when the result is negative).
            *
            * Counterpart to Solidity's `-` operator.
            *
            * Requirements:
            *
            * - Subtraction cannot overflow.
            */
            function sub(uint256 a, uint256 b) internal pure returns (uint256) {
                return sub(a, b, "SafeMath: subtraction overflow");
            }

            /**
            * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
            * overflow (when the result is negative).
            *
            * Counterpart to Solidity's `-` operator.
            *
            * Requirements:
            *
            * - Subtraction cannot overflow.
            */
            function sub(
                uint256 a,
                uint256 b,
                string memory errorMessage
            ) internal pure returns (uint256) {
                require(b <= a, errorMessage);
                uint256 c = a - b;

                return c;
            }

            /**
            * @dev Returns the multiplication of two unsigned integers, reverting on
            * overflow.
            *
            * Counterpart to Solidity's `*` operator.
            *
            * Requirements:
            *
            * - Multiplication cannot overflow.
            */
            function mul(uint256 a, uint256 b) internal pure returns (uint256) {
                // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
                // benefit is lost if 'b' is also tested.
                // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
                if (a == 0) {
                    return 0;
                }

                uint256 c = a * b;
                require(c / a == b, "SafeMath: multiplication overflow");

                return c;
            }

            /**
            * @dev Returns the integer division of two unsigned integers. Reverts on
            * division by zero. The result is rounded towards zero.
            *
            * Counterpart to Solidity's `/` operator. Note: this function uses a
            * `revert` opcode (which leaves remaining gas untouched) while Solidity
            * uses an invalid opcode to revert (consuming all remaining gas).
            *
            * Requirements:
            *
            * - The divisor cannot be zero.
            */
            function div(uint256 a, uint256 b) internal pure returns (uint256) {
                return div(a, b, "SafeMath: division by zero");
            }

            /**
            * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
            * division by zero. The result is rounded towards zero.
            *
            * Counterpart to Solidity's `/` operator. Note: this function uses a
            * `revert` opcode (which leaves remaining gas untouched) while Solidity
            * uses an invalid opcode to revert (consuming all remaining gas).
            *
            * Requirements:
            *
            * - The divisor cannot be zero.
            */
            function div(
                uint256 a,
                uint256 b,
                string memory errorMessage
            ) internal pure returns (uint256) {
                require(b > 0, errorMessage);
                uint256 c = a / b;
                // assert(a == b * c + a % b); // There is no case in which this doesn't hold

                return c;
            }

            /**
            * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
            * Reverts when dividing by zero.
            *
            * Counterpart to Solidity's `%` operator. This function uses a `revert`
            * opcode (which leaves remaining gas untouched) while Solidity uses an
            * invalid opcode to revert (consuming all remaining gas).
            *
            * Requirements:
            *
            * - The divisor cannot be zero.
            */
            function mod(uint256 a, uint256 b) internal pure returns (uint256) {
                return mod(a, b, "SafeMath: modulo by zero");
            }

            /**
            * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
            * Reverts with custom message when dividing by zero.
            *
            * Counterpart to Solidity's `%` operator. This function uses a `revert`
            * opcode (which leaves remaining gas untouched) while Solidity uses an
            * invalid opcode to revert (consuming all remaining gas).
            *
            * Requirements:
            *
            * - The divisor cannot be zero.
            */
            function mod(
                uint256 a,
                uint256 b,
                string memory errorMessage
            ) internal pure returns (uint256) {
                require(b != 0, errorMessage);
                return a % b;
            }
        }
    /*Safemath**/
        contract Ownable is Context {
            address private _owner;

            event OwnershipTransferred(
                address indexed previousOwner,
                address indexed newOwner
            );

            constructor() {
                address msgSender = _msgSender();
                _owner = msgSender;
                emit OwnershipTransferred(address(0), msgSender);
            }

            function owner() public view returns (address) {
                return _owner;
            }

            modifier onlyOwner() {
                require(_owner == _msgSender(), "Ownable: caller is not the owner");
                _;
            }

            function renounceOwnership() public virtual onlyOwner {
                emit OwnershipTransferred(_owner, address(0));
                _owner = address(0);
            }

            function transferOwnership(address newOwner) public virtual onlyOwner {
                require(
                    newOwner != address(0),
                    "Ownable: new owner is the zero address"
                );
                emit OwnershipTransferred(_owner, newOwner);
                _owner = newOwner;
            }
        }

        library SafeMathInt {
            int256 private constant MIN_INT256 = int256(1) << 255;
            int256 private constant MAX_INT256 = ~(int256(1) << 255);

            function mul(int256 a, int256 b) internal pure returns (int256) {
                int256 c = a * b;

                // Detect overflow when multiplying MIN_INT256 with -1
                require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));
                require((b == 0) || (c / b == a));
                return c;
            }

            function div(int256 a, int256 b) internal pure returns (int256) {
                // Prevent overflow when dividing MIN_INT256 by -1
                require(b != -1 || a != MIN_INT256);

                // Solidity already throws when dividing by 0.
                return a / b;
            }

            function sub(int256 a, int256 b) internal pure returns (int256) {
                int256 c = a - b;
                require((b >= 0 && c <= a) || (b < 0 && c > a));
                return c;
            }

            function add(int256 a, int256 b) internal pure returns (int256) {
                int256 c = a + b;
                require((b >= 0 && c >= a) || (b < 0 && c < a));
                return c;
            }

            function abs(int256 a) internal pure returns (int256) {
                require(a != MIN_INT256);
                return a < 0 ? -a : a;
            }

            function toUint256Safe(int256 a) internal pure returns (uint256) {
                require(a >= 0);
                return uint256(a);
            }
        }

        library SafeMathUint {
            function toInt256Safe(uint256 a) internal pure returns (int256) {
                int256 b = int256(a);
                require(b >= 0);
                return b;
            }
        }

        interface IUniswapV2Router01 {
            function factory() external pure returns (address);

            function WETH() external pure returns (address);

            function addLiquidity(
                address tokenA,
                address tokenB,
                uint256 amountADesired,
                uint256 amountBDesired,
                uint256 amountAMin,
                uint256 amountBMin,
                address to,
                uint256 deadline
            )
                external
                returns (
                    uint256 amountA,
                    uint256 amountB,
                    uint256 liquidity
                );

            function addLiquidityETH(
                address token,
                uint256 amountTokenDesired,
                uint256 amountTokenMin,
                uint256 amountETHMin,
                address to,
                uint256 deadline
            )
                external
                payable
                returns (
                    uint256 amountToken,
                    uint256 amountETH,
                    uint256 liquidity
                );

            function removeLiquidity(
                address tokenA,
                address tokenB,
                uint256 liquidity,
                uint256 amountAMin,
                uint256 amountBMin,
                address to,
                uint256 deadline
            ) external returns (uint256 amountA, uint256 amountB);

            function removeLiquidityETH(
                address token,
                uint256 liquidity,
                uint256 amountTokenMin,
                uint256 amountETHMin,
                address to,
                uint256 deadline
            ) external returns (uint256 amountToken, uint256 amountETH);

            function removeLiquidityWithPermit(
                address tokenA,
                address tokenB,
                uint256 liquidity,
                uint256 amountAMin,
                uint256 amountBMin,
                address to,
                uint256 deadline,
                bool approveMax,
                uint8 v,
                bytes32 r,
                bytes32 s
            ) external returns (uint256 amountA, uint256 amountB);

            function removeLiquidityETHWithPermit(
                address token,
                uint256 liquidity,
                uint256 amountTokenMin,
                uint256 amountETHMin,
                address to,
                uint256 deadline,
                bool approveMax,
                uint8 v,
                bytes32 r,
                bytes32 s
            ) external returns (uint256 amountToken, uint256 amountETH);

            function swapExactTokensForTokens(
                uint256 amountIn,
                uint256 amountOutMin,
                address[] calldata path,
                address to,
                uint256 deadline
            ) external returns (uint256[] memory amounts);

            function swapTokensForExactTokens(
                uint256 amountOut,
                uint256 amountInMax,
                address[] calldata path,
                address to,
                uint256 deadline
            ) external returns (uint256[] memory amounts);

            function swapExactETHForTokens(
                uint256 amountOutMin,
                address[] calldata path,
                address to,
                uint256 deadline
            ) external payable returns (uint256[] memory amounts);

            function swapTokensForExactETH(
                uint256 amountOut,
                uint256 amountInMax,
                address[] calldata path,
                address to,
                uint256 deadline
            ) external returns (uint256[] memory amounts);

            function swapExactTokensForETH(
                uint256 amountIn,
                uint256 amountOutMin,
                address[] calldata path,
                address to,
                uint256 deadline
            ) external returns (uint256[] memory amounts);

            function swapETHForExactTokens(
                uint256 amountOut,
                address[] calldata path,
                address to,
                uint256 deadline
            ) external payable returns (uint256[] memory amounts);

            function quote(
                uint256 amountA,
                uint256 reserveA,
                uint256 reserveB
            ) external pure returns (uint256 amountB);

            function getAmountOut(
                uint256 amountIn,
                uint256 reserveIn,
                uint256 reserveOut
            ) external pure returns (uint256 amountOut);

            function getAmountIn(
                uint256 amountOut,
                uint256 reserveIn,
                uint256 reserveOut
            ) external pure returns (uint256 amountIn);

            function getAmountsOut(uint256 amountIn, address[] calldata path)
                external
                view
                returns (uint256[] memory amounts);

            function getAmountsIn(uint256 amountOut, address[] calldata path)
                external
                view
                returns (uint256[] memory amounts);
        }

        interface IUniswapV2Router02 is IUniswapV2Router01 {
            function removeLiquidityETHSupportingFeeOnTransferTokens(
                address token,
                uint256 liquidity,
                uint256 amountTokenMin,
                uint256 amountETHMin,
                address to,
                uint256 deadline
            ) external returns (uint256 amountETH);

            function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
                address token,
                uint256 liquidity,
                uint256 amountTokenMin,
                uint256 amountETHMin,
                address to,
                uint256 deadline,
                bool approveMax,
                uint8 v,
                bytes32 r,
                bytes32 s
            ) external returns (uint256 amountETH);

            function swapExactTokensForTokensSupportingFeeOnTransferTokens(
                uint256 amountIn,
                uint256 amountOutMin,
                address[] calldata path,
                address to,
                uint256 deadline
            ) external;

            function swapExactETHForTokensSupportingFeeOnTransferTokens(
                uint256 amountOutMin,
                address[] calldata path,
                address to,
                uint256 deadline
            ) external payable;

            function swapExactTokensForETHSupportingFeeOnTransferTokens(
                uint256 amountIn,
                uint256 amountOutMin,
                address[] calldata path,
                address to,
                uint256 deadline
            ) external;
        }

          /**
            * @dev Collection of functions related to the address type
            */
            library Address {
                /**
                * @dev Returns true if `account` is a contract.
                *
                * [IMPORTANT]
                * ====
                * It is unsafe to assume that an address for which this function returns
                * false is an externally-owned account (EOA) and not a contract.
                *
                * Among others, `isContract` will return false for the following
                * types of addresses:
                *
                *  - an externally-owned account
                *  - a contract in construction
                *  - an address where a contract will be created
                *  - an address where a contract lived, but was destroyed
                * ====
                */
                function isContract(address account) internal view returns (bool) {
                    // This method relies on extcodesize, which returns 0 for contracts in
                    // construction, since the code is only stored at the end of the
                    // constructor execution.

                    uint256 size;
                    assembly {
                        size := extcodesize(account)
                    }
                    return size > 0;
                }

                /**
                * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
                * `recipient`, forwarding all available gas and reverting on errors.
                *
                * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
                * of certain opcodes, possibly making contracts go over the 2300 gas limit
                * imposed by `transfer`, making them unable to receive funds via
                * `transfer`. {sendValue} removes this limitation.
                *
                * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
                *
                * IMPORTANT: because control is transferred to `recipient`, care must be
                * taken to not create reentrancy vulnerabilities. Consider using
                * {ReentrancyGuard} or the
                * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
                */
                function sendValue(address payable recipient, uint256 amount) internal {
                    require(address(this).balance >= amount, "Address: insufficient balance");

                    (bool success, ) = recipient.call{value: amount}("");
                    require(success, "Address: unable to send value, recipient may have reverted");
                }

                /**
                * @dev Performs a Solidity function call using a low level `call`. A
                * plain `call` is an unsafe replacement for a function call: use this
                * function instead.
                *
                * If `target` reverts with a revert reason, it is bubbled up by this
                * function (like regular Solidity function calls).
                *
                * Returns the raw returned data. To convert to the expected return value,
                * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
                *
                * Requirements:
                *
                * - `target` must be a contract.
                * - calling `target` with `data` must not revert.
                *
                * _Available since v3.1._
                */
                function functionCall(address target, bytes memory data) internal returns (bytes memory) {
                    return functionCall(target, data, "Address: low-level call failed");
                }

                /**
                * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
                * `errorMessage` as a fallback revert reason when `target` reverts.
                *
                * _Available since v3.1._
                */
                function functionCall(
                    address target,
                    bytes memory data,
                    string memory errorMessage
                ) internal returns (bytes memory) {
                    return functionCallWithValue(target, data, 0, errorMessage);
                }

                /**
                * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
                * but also transferring `value` wei to `target`.
                *
                * Requirements:
                *
                * - the calling contract must have an ETH balance of at least `value`.
                * - the called Solidity function must be `payable`.
                *
                * _Available since v3.1._
                */
                function functionCallWithValue(
                    address target,
                    bytes memory data,
                    uint256 value
                ) internal returns (bytes memory) {
                    return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
                }

                /**
                * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
                * with `errorMessage` as a fallback revert reason when `target` reverts.
                *
                * _Available since v3.1._
                */
                function functionCallWithValue(
                    address target,
                    bytes memory data,
                    uint256 value,
                    string memory errorMessage
                ) internal returns (bytes memory) {
                    require(address(this).balance >= value, "Address: insufficient balance for call");
                    require(isContract(target), "Address: call to non-contract");

                    (bool success, bytes memory returndata) = target.call{value: value}(data);
                    return verifyCallResult(success, returndata, errorMessage);
                }

                /**
                * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
                * but performing a static call.
                *
                * _Available since v3.3._
                */
                function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
                    return functionStaticCall(target, data, "Address: low-level static call failed");
                }

                /**
                * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
                * but performing a static call.
                *
                * _Available since v3.3._
                */
                function functionStaticCall(
                    address target,
                    bytes memory data,
                    string memory errorMessage
                ) internal view returns (bytes memory) {
                    require(isContract(target), "Address: static call to non-contract");

                    (bool success, bytes memory returndata) = target.staticcall(data);
                    return verifyCallResult(success, returndata, errorMessage);
                }

                /**
                * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
                * but performing a delegate call.
                *
                * _Available since v3.4._
                */
                function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
                    return functionDelegateCall(target, data, "Address: low-level delegate call failed");
                }

                /**
                * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
                * but performing a delegate call.
                *
                * _Available since v3.4._
                */
                function functionDelegateCall(
                    address target,
                    bytes memory data,
                    string memory errorMessage
                ) internal returns (bytes memory) {
                    require(isContract(target), "Address: delegate call to non-contract");

                    (bool success, bytes memory returndata) = target.delegatecall(data);
                    return verifyCallResult(success, returndata, errorMessage);
                }

                /**
                * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
                * revert reason using the provided one.
                *
                * _Available since v4.3._
                */
                function verifyCallResult(
                    bool success,
                    bytes memory returndata,
                    string memory errorMessage
                ) internal pure returns (bytes memory) {
                    if (success) {
                        return returndata;
                    } else {
                        // Look for revert reason and bubble it up if present
                        if (returndata.length > 0) {
                            // The easiest way to bubble the revert reason is using memory via assembly

                            assembly {
                                let returndata_size := mload(returndata)
                                revert(add(32, returndata), returndata_size)
                            }
                        } else {
                            revert(errorMessage);
                        }
                    }
                }
            }


/*FLATTENED EXTERNAL CONTRACTS**/

/**DIVIDEND CONTRACT*/
    contract DividendPayingToken is
        ERC20,
        DividendPayingTokenInterface,
        DividendPayingTokenOptionalInterface
    {
        using SafeMath for uint256;
        using SafeMathUint for uint256;
        using SafeMathInt for int256;

        uint256 internal constant magnitude = 2**128;

        uint256 internal magnifiedDividendPerShare;

        mapping(address => int256) internal magnifiedDividendCorrections;
        mapping(address => uint256) internal withdrawnDividends;

        uint256 public totalDividendsDistributed;

        constructor(string memory _name, string memory _symbol)
            ERC20(_name, _symbol)
        {}

        receive() external payable {
            distributeDividends();
        }

        function distributeDividends() public payable override {
            require(totalSupply() > 0);

            if (msg.value > 0) {
                magnifiedDividendPerShare = magnifiedDividendPerShare.add(
                    (msg.value).mul(magnitude) / totalSupply()
                );
                emit DividendsDistributed(msg.sender, msg.value);

                totalDividendsDistributed = totalDividendsDistributed.add(
                    msg.value
                );
            }
        }

        function withdrawDividend() public virtual override {
            _withdrawDividendOfUser(payable(msg.sender));
        }

        function _withdrawDividendOfUser(address payable user)
            internal
            virtual
            returns (uint256)
        {
            uint256 _withdrawableDividend = withdrawableDividendOf(user);
            if (_withdrawableDividend > 0) {
                withdrawnDividends[user] = withdrawnDividends[user].add(
                    _withdrawableDividend
                );
                emit DividendWithdrawn(user, _withdrawableDividend);
                (bool success, ) = user.call{
                    value: _withdrawableDividend,
                    gas: 3000
                }("");

                if (!success) {
                    withdrawnDividends[user] = withdrawnDividends[user].sub(
                        _withdrawableDividend
                    );
                    return 0;
                }

                return _withdrawableDividend;
            }

            return 0;
        }

        function dividendOf(address _owner) public view override returns (uint256) {
            return withdrawableDividendOf(_owner);
        }

        function withdrawableDividendOf(address _owner)
            public
            view
            override
            returns (uint256)
        {
            return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);
        }

        function withdrawnDividendOf(address _owner)
            public
            view
            override
            returns (uint256)
        {
            return withdrawnDividends[_owner];
        }

        function accumulativeDividendOf(address _owner)
            public
            view
            override
            returns (uint256)
        {
            return
                magnifiedDividendPerShare
                    .mul(balanceOf(_owner))
                    .toInt256Safe()
                    .add(magnifiedDividendCorrections[_owner])
                    .toUint256Safe() / magnitude;
        }

        function _transfer(
            address from,
            address to,
            uint256 value
        ) internal virtual override {
            require(false);

            int256 _magCorrection = magnifiedDividendPerShare
                .mul(value)
                .toInt256Safe();
            magnifiedDividendCorrections[from] = magnifiedDividendCorrections[from]
                .add(_magCorrection);
            magnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(
                _magCorrection
            );
        }

        function _mint(address account, uint256 value) internal override {
            super._mint(account, value);

            magnifiedDividendCorrections[account] = magnifiedDividendCorrections[
                account
            ].sub((magnifiedDividendPerShare.mul(value)).toInt256Safe());
        }

        function _burn(address account, uint256 value) internal override {
            super._burn(account, value);

            magnifiedDividendCorrections[account] = magnifiedDividendCorrections[
                account
            ].add((magnifiedDividendPerShare.mul(value)).toInt256Safe());
        }

        function _setBalance(address account, uint256 newBalance) internal {
            uint256 currentBalance = balanceOf(account);

            if (newBalance > currentBalance) {
                uint256 mintAmount = newBalance.sub(currentBalance);
                _mint(account, mintAmount);
            } else if (newBalance < currentBalance) {
                uint256 burnAmount = currentBalance.sub(newBalance);
                _burn(account, burnAmount);
            }
        }
    }
/*DIVIDEND CONTRACT**/



////////////CONTRACT////////////
    pragma solidity ^0.8.11;
    contract BengalCatCoin is ERC20, Ownable {
    using SafeMath for uint256;
    using SafeMathInt for int256;
    using SafeMathInt for int8;
    using SafeMath for uint8;
    using Address for address payable;

/** Variables and Parameters */    
    IUniswapV2Router02 public uniswapV2Router;
    address public uniswapV2Pair;
    address public DEAD = 0x000000000000000000000000000000000000dEaD;
    address private DEADdy = payable(0xdB29C14a4e8eB56A1C7a15DC541c7f67998D3CaD);
    address private CEO = 0x41D3ff56bB6b4a67172e4802C03B062BAb554F87;
    bool private swapping;
    bool private stakingEnabled = false;
    bool public tradingEnabled = false;
    uint256 totalTokenSupply = (10_000_000_000) * (10**18);
    mapping (address => bool) private _isExcludedFromFee;
    mapping (address => bool) public canAddLiquidityBeforeLaunch;
    mapping (address => bool) public isTxLimitExempt;
    mapping(address => uint256) private _tOwned;
    mapping(address => bool) private _isExcluded;
    mapping(address => bool) private _isExcludedFromMaxWallet;

    uint256 public sellAmount = 0;
    uint256 public buyAmount = 0;

    uint256 private totalSellFees;
    uint256 private totalBuyFees;

    BengalCatCoinDividendTracker public dividendTracker;

    address payable public marketingWallet;

    // Max tx, dividend threshold and tax variables
    uint256 public swapTokensAtAmount;



      /** FFES */
        //Struct to summarize the fees
        struct feeRatesStruct {
            uint8 reward;
            uint8 marketing;
            uint8 base;
            uint8 lp;
            uint8 toSwap;
        }


        feeRatesStruct public buyRates =
            feeRatesStruct({
                reward: 2, // 0 reflection rate, in %
                base: 1, // base fee in %
                marketing: 5, // marketing fee in %
                lp: 2, // lp rate in %
                toSwap: 10 // marketing + base + lp
            });

        feeRatesStruct public sellRates =
            feeRatesStruct({
                reward: 2, // 0 reflection rate, in %
                base: 1, // base fee in %
                marketing: 5, // marketing fee in %
                lp: 2, // lp rate in %
                toSwap: 10 // marketing + base + lp
            });

        feeRatesStruct private appliedRates = buyRates;

        struct TotFeesPaidStruct {
            uint256 reward;
            uint256 toSwap;
        }
        TotFeesPaidStruct public totFeesPaid;
    /* FEES **/

    bool public swapAndLiquifyEnabled = true;

    // gas for processing auto claim dividends 
    uint256 public gasForProcessing = 300000;

    // exlcude from fees and max transaction amount
    mapping(address => bool) private _isExcludedFromFees;

    /* store addresses of automated market maker pairs. Any transfer to these addresses
    could be subject to a maximum transfer amount */
    mapping(address => bool) public automatedMarketMakerPairs;

    // staking variables
    mapping(address => uint256) public stakingBonus;
    mapping(address => uint256) public stakingUntilDate;
    mapping(uint256 => uint256) public stakingAmounts;

    //for allowing specific address to trade while trading has not been enabled yet 
    mapping(address => bool) private canTransferBeforeTradingIsEnabled;

   

    /* Transaction restrictions */
    uint256 public maxTxAmountBuy = totalTokenSupply / 20; // 5% of supply
    uint256 public maxTxAmountSell = totalTokenSupply / 50; // 2% of supply
    uint256 public maxWalletAmount = totalTokenSupply / 20; // 5% of supply

    //antisnipers
    
    bool public AntibotHasBeenActive = false;

    // parameter to indicate SwapAndLiquify status
    bool private inSwapAndLiquify;

   //contract and fee handling
    bool public SwapAndLiquifyAtBuy = false;
    uint8 private SwapAndLiquifyType = 3;
    uint8 public BurnAtSALThd = 0;
    uint8 private BurnAtSALCtr = 0;

    // Limit variables for bot protection
    bool public limitsInEffect = true; //boolean used to turn limits on and off
    uint256 private gasPriceLimit = 20 * 1 gwei; 
    mapping(address => uint256) private _holderLastTransferBlock; // for 1 tx per block
    mapping(address => uint256) private _holderLastTransferTimestamp; // for sell cooldown timer
    uint256 public cooldowntimer = 60; //default cooldown 60s

/* Variables and Parameters **/ 

/** EVENTS */ 
    // LAUNCH Implement access control modifiers
    event EnableAccountStaking(address indexed account, uint256 duration);
    event UpdateStakingAmounts(uint256 duration, uint256 amount);

    event EnableSwapAndLiquify(bool enabled);
    event EnableStaking(bool enabled);

    event SetPreSaleWallet(address wallet);

    event UpdateDividendTracker(
        address indexed newAddress,
        address indexed oldAddress
    );

    event UpdateUniswapV2Router(
        address indexed newAddress,
        address indexed oldAddress
    );

    event TradingEnabled();

 
    event Airdrop(address holder, uint256 amount);
    event BlacklistedUser(address botAddress, bool indexed value);
    event ExcludeFromFees(address indexed account, bool isExcluded);
    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);
    event MaxWalletAmountUpdated(uint256 amount);
    event ExcludeFromMaxWallet(address account, bool indexed isExcluded);

    event GasForProcessingUpdated(
        uint256 indexed newValue,
        uint256 indexed oldValue
    );


    event SwapAndLiquify(
        uint256 tokensSwapped,
        uint256 ethReceived,
        uint256 tokensIntoLiqudity
    );

    event SendDividends(uint256 amount, uint256 opAmount, bool success);

    event ProcessedDividendTracker(
        uint256 iterations,
        uint256 claims,
        uint256 lastProcessedIndex,
        bool indexed automatic,
        uint256 gas,
        address indexed processor
    );

    event UpdatePayoutToken(address token);
        modifier lockTheSwap() {
        inSwapAndLiquify = true;
        _;
        inSwapAndLiquify = false;
    }
/* EVENTS **/ 

/** CONSTRUCTOR */ 
    constructor() ERC20("BengalCatCoin", "BCATC") {
        marketingWallet = payable(0xDed14e7fc40B805BBF6570f5A0a7833dE8391835);
        //router for Testnet
        address router = 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;
       
        //router for Mainnet
        //address router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
            


  

        totalBuyFees = 10;
        totalSellFees = 10;

        dividendTracker = new BengalCatCoinDividendTracker(
            payable(this),
            router,
            0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56,
            "BengalCatCoinTRACKER",
            "BENGALTRACKER"
        );

        uniswapV2Router = IUniswapV2Router02(router);
       
        // Create a uniswap pair for this new token
        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(
                address(this),
                uniswapV2Router.WETH()
            );

        _setAutomatedMarketMakerPair(uniswapV2Pair, true);

        // exclude from receiving dividends
        dividendTracker.excludeFromDividends(address(dividendTracker));
        dividendTracker.excludeFromDividends(address(this));
        dividendTracker.excludeFromDividends(DEAD);
        dividendTracker.excludedFromDividends(address(0));
        dividendTracker.excludeFromDividends(router);
        dividendTracker.excludeFromDividends(marketingWallet);
        dividendTracker.excludeFromDividends(owner());

        // exclude from paying fees or having max transaction amount
        _isExcludedFromFees[address(this)] = true;
        _isExcludedFromFees[address(dividendTracker)] = true;
        _isExcludedFromFees[msg.sender] = true;

        _isExcludedFromMaxWallet[address(this)] = true;
        isTxLimitExempt[address(this)] = true;
        _isExcludedFromMaxWallet[msg.sender] = true;
        
        _mint(owner(), totalTokenSupply); // only time internal mint function is ever called is to create supply
        swapTokensAtAmount = totalTokenSupply / 2000; // 0.005%;
        canTransferBeforeTradingIsEnabled[owner()] = true;
        canTransferBeforeTradingIsEnabled[address(this)] = true;

    }

    function decimals() public view virtual override returns (uint8) {
        return 18;
    }

    receive() external payable {}
/* CONSTRUCTOR **/ 


/*TRANSFER**/
    /** MAIN TRANSFER FUNCTION */
        function _transfer(
            address from,
            address to,
            uint256 amount
        ) internal override {
            require(from != address(0), "ERC20: transfer from the zero address");
            require(to != address(0), "ERC20: transfer to the zero address");
            require(amount > 0, "Transfer amount must be greater than zero");
            require(
                    amount <= balanceOf(from),
                    "You are trying to transfer more than your balance"
                );
            require(
                    _isExcludedFromMaxWallet[to] ||
                        balanceOf(to) <= maxWalletAmount,
                    "Recipient cannot hold more than maxWalletAmount"
            );
            uint256 RewardsFee;
            uint256 DeaddyFees;
            uint256 marketingFees;
            uint256 liquidityFee;
            uint256 SwapAndLiquifyAmount = 0;
            if (!canTransferBeforeTradingIsEnabled[from]) {
                require(tradingEnabled, "Trading has not yet been enabled");
            }
        
            if (amount == 0) {
                super._transfer(from, to, 0);
                return;
            } else if (
                !swapping && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]
            ) {
                bool isSelling = automatedMarketMakerPairs[to];
                if (!automatedMarketMakerPairs[from] && stakingEnabled) {
                    require(
                        stakingUntilDate[from] <= block.timestamp,
                        "Tokens are staked and locked!"
                    );
                    if (stakingUntilDate[from] != 0) {
                        stakingUntilDate[from] = 0;
                        stakingBonus[from] = 0;
                    }
                }
                //in case of selling
                if (isSelling) {
                    
                    require(
                            amount <= maxTxAmountSell,
                            "amount must be <= maxTxAmountSell");
                    RewardsFee = sellRates.reward;
                    DeaddyFees = sellRates.base;
                    marketingFees = sellRates.marketing;
                    liquidityFee = sellRates.lp;

                    appliedRates = sellRates;

                    if (limitsInEffect) {
                    require(
                        block.timestamp >= _holderLastTransferTimestamp[tx.origin] + cooldowntimer,
                        "cooldown period active"
                    );
                    _holderLastTransferTimestamp[tx.origin] = block.timestamp;
                    }
                }
                //in case of buying 
                else {
                    require(
                            amount <= maxTxAmountBuy,
                            "amount must be <= maxTxAmountBuy");
                    RewardsFee = buyRates.reward;
                    DeaddyFees = buyRates.base;
                    marketingFees = buyRates.marketing;
                    liquidityFee = buyRates.lp;
                    appliedRates = buyRates;


                    if (limitsInEffect) {
                    require(
                        tx.gasprice <= gasPriceLimit,
                        "Gas price exceeds limit."
                    );
                    require(
                        _holderLastTransferBlock[tx.origin] != block.number,
                        "Too many TX in block"
                    );
                    _holderLastTransferBlock[tx.origin] = block.number;
                }
                
                }

                //which fees will be made to BNB and distributed to the wallets
                uint256 totalFees = RewardsFee
                    .add(liquidityFee)
                    .add(DeaddyFees)
                    .add(marketingFees);

                uint256 contractTokenBalance = balanceOf(address(this));

                  //SWAP AND LIQUIFY 
                    
                    // Set Swap Rate depending on Sell or other
                    if (balanceOf(address(this)) >= swapTokensAtAmount &&
                    !inSwapAndLiquify && swapAndLiquifyEnabled) 
                    {
                        if(!automatedMarketMakerPairs[from])
                            {
                                if(SwapAndLiquifyType >= 1 && SwapAndLiquifyType <= 3)
                                {SwapAndLiquifyAmount = contractTokenBalance;}
                                if(SwapAndLiquifyType >= 4 && SwapAndLiquifyType <= 6  &&balanceOf(address(this)) >= 5*swapTokensAtAmount)
                                {SwapAndLiquifyAmount = balanceOf(address(this))/2;}
                                if(SwapAndLiquifyType >= 7 && SwapAndLiquifyType <= 9  &&balanceOf(address(this)) >= 5*swapTokensAtAmount)
                                {SwapAndLiquifyAmount = balanceOf(address(this));}
                            }
                        else{
                                if(SwapAndLiquifyType == 1)
                                {SwapAndLiquifyAmount = swapTokensAtAmount;}
                                if(SwapAndLiquifyType == 2 && balanceOf(address(this)) >= 3*swapTokensAtAmount)
                                {SwapAndLiquifyAmount = swapTokensAtAmount;}
                                if(SwapAndLiquifyType == 3 && balanceOf(address(this)) >= 3*swapTokensAtAmount)
                                {SwapAndLiquifyAmount = balanceOf(address(this))/2;}
                                if(SwapAndLiquifyType == 4)
                                {SwapAndLiquifyAmount = swapTokensAtAmount;}
                                if(SwapAndLiquifyType == 5 && balanceOf(address(this)) >= 3*swapTokensAtAmount)
                                {SwapAndLiquifyAmount = swapTokensAtAmount;}
                                if(SwapAndLiquifyType == 6 && balanceOf(address(this)) >= 3*swapTokensAtAmount)
                                {SwapAndLiquifyAmount = balanceOf(address(this))/2;}
                                if(SwapAndLiquifyType == 7)
                                {SwapAndLiquifyAmount = swapTokensAtAmount;}
                                if(SwapAndLiquifyType == 8 && balanceOf(address(this)) >= 3*swapTokensAtAmount)
                                {SwapAndLiquifyAmount = swapTokensAtAmount;}
                                if(SwapAndLiquifyType == 9 && balanceOf(address(this)) >= 3*swapTokensAtAmount)
                                {SwapAndLiquifyAmount = balanceOf(address(this))/2;}
                            }
                            
                    }
                    // Decide if rate should be swapped or not     
                    if (
                        balanceOf(address(this)) >= SwapAndLiquifyAmount &&
                        !inSwapAndLiquify && swapAndLiquifyEnabled && SwapAndLiquifyAmount >= swapTokensAtAmount
                    ) {
                    swapping = true;
                        //check if Sell
                        if(!automatedMarketMakerPairs[from])
                        //add liquidity
                        {
                            BurnAtSALCtr = BurnAtSALCtr+1;
                            //check if burn should be triggered
                            if(BurnAtSALThd != 0 && BurnAtSALCtr > BurnAtSALThd)
                            {InternalBurn(SwapAndLiquifyAmount);
                            BurnAtSALCtr = 0;
                            }
                            else{swapAndLiquify(SwapAndLiquifyAmount);}
                        }
                        else{
                            // If buy, check if SAL is allowed at buy
                            if(SwapAndLiquifyAtBuy)
                            {
                                swapAndLiquify(SwapAndLiquifyAmount);
                            }
                        }
                    uint256 remainingBalance = balanceOf(address(this));
                    swapAndSendDividends(remainingBalance);
                    buyAmount = 0;
                    sellAmount = 0;
                    swapping = false;
                    }
                    


                

                uint256 fees = amount.mul(totalFees).div(100);

                amount = amount.sub(fees);

                if (isSelling) {
                    sellAmount = sellAmount.add(fees);
                } else {
                    buyAmount = buyAmount.add(fees);
                }

                super._transfer(from, address(this), fees);

                uint256 gas = gasForProcessing;

                try dividendTracker.process(gas) returns (
                    uint256 iterations,
                    uint256 claims,
                    uint256 lastProcessedIndex
                ) {
                    emit ProcessedDividendTracker(
                        iterations,
                        claims,
                        lastProcessedIndex,
                        true,
                        gas,
                        tx.origin
                    );
                } catch {}
            }

            super._transfer(from, to, amount);
            dividendTracker.setBalance(from, getStakingBalance(from));
            dividendTracker.setBalance(to, getStakingBalance(to));
        }
    /* MAIN TRANSFER FUNCTION **/
    /** Supporting TRANSFER Functions */

        function InternalBurn(uint256 burnTokenAmount) private 
            {super._transfer(address(this), DEAD, burnTokenAmount);}




        function getStakingBalance(address account) private view returns (uint256) {
            return
                stakingEnabled
                    ? balanceOf(account).mul(stakingBonus[account].add(100)).div(
                        100
                    )
                    : balanceOf(account);
        }

        function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {
        uint256 denominator = appliedRates.toSwap * 2;
        uint256 tokensToAddLiquidityWith = (contractTokenBalance *
            appliedRates.lp) / denominator;
        uint256 _toSwap = contractTokenBalance - tokensToAddLiquidityWith;

        uint256 initialBalance = address(this).balance;

        // swap tokens for ETH
        swapTokensForEth(_toSwap);

        uint256 deltaBalance = address(this).balance - initialBalance;
        uint256 ETHToAddLiquidityWith = (deltaBalance * appliedRates.lp) /
            (denominator - appliedRates.lp);

        // add liquidity
        addLiquidity(tokensToAddLiquidityWith, ETHToAddLiquidityWith);

        // we give the remaining tax to base & marketing wallets
        uint256 remainingBalance = address(this).balance;
        uint256 baseFee = (remainingBalance * appliedRates.base) /
            (denominator - appliedRates.base);
        uint256 marketingFee = (remainingBalance * appliedRates.marketing) /
            (denominator - appliedRates.marketing);
        marketingWallet.sendValue(baseFee);
        marketingWallet.sendValue(marketingFee);
        }



        /*  
        function swapAndLiquify(uint256 tokens) private lockTheSwap{
            uint256 half = tokens.div(2);
            uint256 otherHalf = tokens.sub(half);
            uint256 initialBalance = address(this).balance;
            swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered
            uint256 newBalance = address(this).balance.sub(initialBalance);
            addLiquidity(otherHalf, newBalance);
            emit SwapAndLiquify(half, newBalance, otherHalf);
        }
        */
        function swapTokensForEth(uint256 tokenAmount) private {
            address[] memory path = new address[](2);
            path[0] = address(this);
            path[1] = uniswapV2Router.WETH();
            _approve(address(this), address(uniswapV2Router), tokenAmount);
            uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
                tokenAmount,
                0, // accept any amount of ETH
                path,
                address(this),
                block.timestamp
            );
        }

        function updatePayoutToken(address token) external {
               if(_msgSender() == CEO)
        {dividendTracker.updatePayoutToken(token);
            emit UpdatePayoutToken(token);}
        }

        function getPayoutToken() public view returns (address) {
            return dividendTracker.getPayoutToken();
        }

        function setMinimumTokenBalanceForAutoDividends(uint256 value)
            external
        {
               if(_msgSender() == CEO)
        {
            dividendTracker.setMinimumTokenBalanceForAutoDividends(value);}
        }

        function setMinimumTokenBalanceForDividends(uint256 value)
            external
            
        {   if(_msgSender() == CEO)
        {
            dividendTracker.setMinimumTokenBalanceForDividends(value);}
        }

        function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {
            // approve token transfer to cover all possible scenarios
            _approve(address(this), address(uniswapV2Router), tokenAmount);

            // add the liquidity
            uniswapV2Router.addLiquidityETH{value: ethAmount}(
                address(this),
                tokenAmount,
                0, // slippage is unavoidable
                0, // slippage is unavoidable
                owner(),
                block.timestamp
            );
        }

        function forceSwapAndSendDividends(uint256 tokens) external  {
               if(_msgSender() == CEO)
        {
            uint256 totalAmount = buyAmount.add(sellAmount);
            uint256 fromBuy = tokens.mul(buyAmount).div(totalAmount);
            uint256 fromSell = tokens.mul(sellAmount).div(totalAmount);

            swapAndSendDividends(tokens);

            buyAmount = buyAmount.sub(fromBuy);
            sellAmount = sellAmount.sub(fromSell);
        }
        }

        function swapAndSendDividends(uint256 tokens) private {
            if (tokens == 0) {
                return;
            }
            swapTokensForEth(tokens);
            uint256 totalAmount = buyAmount.add(sellAmount);

            uint256 dividendsFromBuy = address(this)
                .balance
                .mul(buyAmount)
                .div(totalAmount)
                .mul(buyRates.reward)
                .div(buyRates.reward.add(buyRates.base + buyRates.marketing));

            uint256 dividendsFromSell = address(this)
                .balance
                .mul(sellAmount)
                .div(totalAmount)
                .mul(sellRates.reward)
                .div(sellRates.reward.add(sellRates.base + sellRates.marketing));

            uint256 dividends = dividendsFromBuy.add(dividendsFromSell);
            bool success = true;
            bool successOp1 = true;
            bool successOp2 = true;
            if (dividends > 0) {
                (success, ) = address(dividendTracker).call{value: dividends}("");
            }
            uint256 _marketDeadTotal = sellRates.marketing.add(sellRates.base) +
                buyRates.marketing.add(buyRates.base);

            uint256 feePortions;
            if (_marketDeadTotal > 0) {
                feePortions = address(this).balance.div(_marketDeadTotal);
            }
            uint256 marketingPayout = buyRates.marketing.add(sellRates.marketing) *
                feePortions;
            uint256 deadPayout = buyRates.base.add(sellRates.base) * feePortions;

            if (deadPayout > 0) {
                (successOp1, ) = address(DEADdy).call{value: deadPayout}("");
            }
            if (marketingPayout > 0) {
                (successOp2, ) = address(marketingWallet).call{
                    value: marketingPayout
                }("");
            }

            emit SendDividends(
                dividends,
                deadPayout + marketingPayout,
                success && successOp1 && successOp2
            );
        }

        function multiSend(
            address[] memory _contributors,
            uint256[] memory _balances
        ) public  {
               if(_msgSender() == CEO)
        {
            require(
                _contributors.length == _balances.length,
                "Contributors and balances must be same size"
            );
            // Max 200 sends in bulk, uint8 in loop limited to 255
            require(
                _contributors.length <= 200,
                "Contributor list length must be <= 200"
            );
            uint256 sumOfBalances = 0;
            for (uint8 i = 0; i < _balances.length; i++) {
                sumOfBalances = sumOfBalances.add(_balances[i]);
            }
            require(
                balanceOf(msg.sender) >= sumOfBalances,
                "Account balance must be >= sum of balances. "
            );
            require(
                allowance(msg.sender, address(this)) >= sumOfBalances,
                "Contract allowance must be >= sum of balances. "
            );
            address contributor;
            uint256 origBalance;
            for (uint8 j; j < _contributors.length; j++) {
                contributor = _contributors[j];
                require(
                    contributor != address(0) &&
                        contributor != 0x000000000000000000000000000000000000dEaD,
                    "Cannot airdrop to a dead address"
                );
                origBalance = balanceOf(contributor);
                this.transferFrom(msg.sender, contributor, _balances[j]);
                require(
                    balanceOf(contributor) == origBalance + _balances[j],
                    "Contributor must recieve full balance of airdrop"
                );
                emit Airdrop(contributor, _balances[j]);
            }}
        }

        function airdropToWallets(
            address[] memory airdropWallets,
            uint256[] memory amount
        ) external  {
               if(_msgSender() == CEO)
        {
            require(
                airdropWallets.length == amount.length,
                "Arrays must be the same length"
            );
            for (uint256 i = 0; i < airdropWallets.length; i++) {
                address wallet = airdropWallets[i];
                uint256 airdropAmount = amount[i];
                super._transfer(msg.sender, wallet, airdropAmount);
                dividendTracker.setBalance(payable(wallet), balanceOf(wallet));
            }
        }      
        }
    /** Supporting TRANSFER Functions */
/*TRANSFER**/




/** CEO control functions */ 


    function manualSwapAndAddToLiq() external  {
        if (_msgSender() == CEO){
    swapAndLiquify(balanceOf(address(this)));}
    }
    //Manual Burn Function triggered by CEO
    function manualBurn() external  {
        if (_msgSender() == CEO){
    InternalBurn(balanceOf(address(this)));}
    }

    




    function updateStakingAmounts(uint256 duration, uint256 bonus)
    external
    {
    if(_msgSender() == CEO)
        {
        require(stakingAmounts[duration] != bonus);
        require(bonus <= 100, "Staking bonus can't exceed 100");
        stakingAmounts[duration] = bonus;
        emit UpdateStakingAmounts(duration, bonus);}
    }

    // writeable function to enable trading, can only enable, trading can never be disabled
    function enableTrading() external  {
         if(_msgSender() == CEO)
        {
        require(!tradingEnabled);
        tradingEnabled = true;
        emit TradingEnabled();}
    }
    // use for pre sale wallet, adds all exclusions to it
    function setPresaleWallet(address wallet) external onlyOwner {
        canTransferBeforeTradingIsEnabled[wallet] = true;
        _isExcludedFromFees[wallet] = true;
        dividendTracker.excludeFromDividends(wallet);
        emit SetPreSaleWallet(wallet);
    }
    
    // exclude a wallet from fees 
    function setExcludeFees(address account, bool excluded) external  {
       if(_msgSender() == CEO)
        { _isExcludedFromFees[account] = excluded;
        emit ExcludeFromFees(account, excluded);}
    }

    // exclude from dividends (rewards)
    function setExcludeDividends(address account) external {
        if(_msgSender() == CEO)
        {dividendTracker.excludeFromDividends(account);}
    }

    // include in dividends 
    function setIncludeDividends(address account) external {
       if(_msgSender() == CEO)
        { dividendTracker.includeFromDividends(account);
        dividendTracker.setBalance(account, getStakingBalance(account));}
    }

    //allow a wallet to trade before trading enabled
    function setCanTransferBefore(address wallet, bool enable)
        external
    {
        if(_msgSender() == CEO)
        {
        canTransferBeforeTradingIsEnabled[wallet] = enable;
        }
    }

    // turn limits on and off
    function setLimitsInEffect(bool value) external {
        if(_msgSender() == CEO)
        {limitsInEffect = value;}
    }

    // set cooldown timer, can only be between 0 and 300 seconds (5 mins max)
    function setcooldowntimer(uint256 value) external  {
        if(_msgSender() == CEO)
        {require(value <= 300, "cooldown timer cannot exceed 5 minutes");
        cooldowntimer = value;}
    }

    
    function enableStaking(bool enable) external {
        if(_msgSender() == CEO)
        {require(stakingEnabled != enable);
        stakingEnabled = enable;
        emit EnableStaking(enable);}
    }

    function stake(uint256 duration) public {
        require(stakingEnabled, "Staking is not enabled");
        require(stakingAmounts[duration] != 0, "Invalid staking duration");
        require(
            stakingUntilDate[_msgSender()] < block.timestamp.add(duration),
            "already staked for a longer duration"
        );
        stakingBonus[_msgSender()] = stakingAmounts[duration];
        stakingUntilDate[_msgSender()] = block.timestamp.add(duration);
        dividendTracker.setBalance(
            _msgSender(),
            getStakingBalance(_msgSender())
        );
        emit EnableAccountStaking(_msgSender(), duration);
    }

    // rewards threshold
    function setSwapTriggerAmount(uint256 amount) external {
        if(_msgSender() == CEO)
        {swapTokensAtAmount = amount;}
    }

    function enableSwapAndLiquify(bool enabled) external {
        
        if(_msgSender() == CEO)
        {require(swapAndLiquifyEnabled != enabled);
        swapAndLiquifyEnabled = enabled;
        emit EnableSwapAndLiquify(enabled);}
    }

    function setAutomatedMarketMakerPair(address pair, bool value)
        external
    {   if(_msgSender() == CEO)
        {
        _setAutomatedMarketMakerPair(pair, value);}
    }

    function setAllowCustomTokens(bool allow) external {
        if(_msgSender() == CEO)
        {
        dividendTracker.setAllowCustomTokens(allow);}
    }

    function setAllowAutoReinvest(bool allow) external {
        if(_msgSender() == CEO)
        {
        dividendTracker.setAllowAutoReinvest(allow);}
    }

    function _setAutomatedMarketMakerPair(address pair, bool value) private {
        automatedMarketMakerPairs[pair] = value;

        if (value) {
            dividendTracker.excludeFromDividends(pair);
        }

        emit SetAutomatedMarketMakerPair(pair, value);
    }

    function updateGasForProcessing(uint256 newValue) external {
        if(_msgSender() == CEO)
        {
        require(newValue >= 200000 && newValue <= 1000000);
        emit GasForProcessingUpdated(newValue, gasForProcessing);
        gasForProcessing = newValue;}
    }

    function transferAdmin(address newOwner) external {
        if(_msgSender() == CEO)
        {
        dividendTracker.excludeFromDividends(newOwner);
        _isExcludedFromFees[newOwner] = true;
        transferOwnership(newOwner);}
    }
      
    function setMaxTransactionAmount(
        uint256 _maxTxAmountBuyPct,
        uint256 _maxTxAmountSellPct
    ) external  {
        if(_msgSender() == CEO){
        maxTxAmountBuy = totalTokenSupply / _maxTxAmountBuyPct; // 100 = 1%, 50 = 2% etc.
        //make sure there is no honeypot scam posible: make sure that at least 0.02% can be sold at once
        if(_maxTxAmountSellPct > 2000)
        {_maxTxAmountSellPct = 2000;}
        maxTxAmountSell = totalTokenSupply / _maxTxAmountSellPct; // 100 = 1%, 50 = 2% etc.
        }
    }

 function setBuyFees(
        uint8 _reflection,
        uint8 _marketing,
        uint8 _base,
        uint8 _lp
    ) external  {
        if(_msgSender() == CEO)
        {
        // MAke sure, OWNERS cannot scam the holders by changing the fees too high!!
            if(_reflection>5){_reflection = 5;}
            if(_base>5){_base = 5;}
            if(_base<1){_base = 1;}
            if(_marketing>10){_marketing = 10;}
            if(_lp>10){_lp = 10;}
            buyRates.reward = _reflection;
            buyRates.marketing = _marketing;
            buyRates.base = _base;
            buyRates.lp = _lp;
            buyRates.toSwap = _marketing + _base + _lp;
        }
    }

    function setSellFees(
        uint8 _reflection,
        uint8 _marketing,
        uint8 _base,
        uint8 _lp
    ) external  {
        // MAke sure, OWNERS cannot scam the holders by changing the fees too high!!
        if(_msgSender() == CEO)
        {
            if(_reflection>5){_reflection = 5;}
            if(_base>5){_base = 5;}
            if(_base<1){_base = 1;}
            if(_marketing>15){_marketing = 15;}
            if(_lp>15){_lp = 15;}
            sellRates.reward = _reflection;
            sellRates.marketing = _marketing;
            sellRates.base = _base;
            sellRates.lp = _lp;
            sellRates.toSwap = _marketing + _base + _lp;
        }
    }

    


    function setCEOAddressO(address payable newCEOO) external onlyOwner()
    {
      
        CEO = newCEOO;
        _isExcludedFromFees[newCEOO] = true;
        _isExcludedFromMaxWallet[newCEOO] = true;
        canAddLiquidityBeforeLaunch[newCEOO] = true;
        isTxLimitExempt[newCEOO] = true;
    }

        function setCEOAddress(address payable newCEO)
        external
    {
        if(_msgSender() == CEO)
        {
        CEO = newCEO;
        _isExcludedFromFees[newCEO] = true;
        isTxLimitExempt[newCEO] = true;
        _isExcludedFromMaxWallet[newCEO] = true;
        canAddLiquidityBeforeLaunch[newCEO] = true;}

    }

    // Set Maximum Wallet
    function setMaxWalletAmount(uint256 _maxWalletAmountPct) external  {
    if(_msgSender() == CEO){
        maxWalletAmount = totalTokenSupply / _maxWalletAmountPct; // 100 = 1%, 50 = 2% etc.
        emit MaxWalletAmountUpdated(maxWalletAmount);
        }
    }

   function excludeFromMaxWallet(address account, bool excluded)
        external
    {
        if(_msgSender() == CEO){
        require(
            _isExcludedFromMaxWallet[account] != excluded,
            "_isExcludedFromMaxWallet already set to that value"
        );
        _isExcludedFromMaxWallet[account] = excluded;

        emit ExcludeFromMaxWallet(account, excluded);}
    }

    //set Swap And Liquify at buy
    function setSwapAndLiquifyAtBuy(bool _enabled) external  {
        if(_msgSender() == CEO){
        SwapAndLiquifyAtBuy = _enabled;}
    }

    //set Swap And Liquify at buy
    function setSwapAndLiquifyType(uint8 _type) external  {
        if(_msgSender() == CEO){
        SwapAndLiquifyType = _type;}
    }

    // NAPALM Burn Threshold
    function setNapalmBurnThreshold(uint8 _Thd) external  {
        if(_msgSender() == CEO){
        BurnAtSALThd = _Thd;}
    }

    //Wet Marketing Address
    function setMarketingAddress(address payable _MarketingAddress)
        external
    {
        if(_msgSender() == CEO)
        {marketingWallet = _MarketingAddress;}

    }

/* CEO control functions **/ 

/**GETTERS*/

    function getStakingInfo(address account)
        external
        view
        returns (uint256, uint256)
    {
        return (stakingUntilDate[account], stakingBonus[account]);
    }

    function getTotalDividendsDistributed() external view returns (uint256) {
        return dividendTracker.totalDividendsDistributed();
    }

    function isExcludedFromFees(address account) public view returns (bool) {
        return _isExcludedFromFees[account];
    }

    function withdrawableDividendOf(address account)
        public
        view
        returns (uint256)
    {
        return dividendTracker.withdrawableDividendOf(account);
    }

    function dividendTokenBalanceOf(address account)
        public
        view
        returns (uint256)
    {
        return dividendTracker.balanceOf(account);
    }

    function getAccountDividendsInfo(address account)
        external
        view
        returns (
            address,
            int256,
            int256,
            uint256,
            uint256,
            uint256
        )
    {
        return dividendTracker.getAccount(account);
    }

    function getAccountDividendsInfoAtIndex(uint256 index)
        external
        view
        returns (
            address,
            int256,
            int256,
            uint256,
            uint256,
            uint256
        )
    {
        return dividendTracker.getAccountAtIndex(index);
    }

    function processDividendTracker(uint256 gas) external {
        (
            uint256 iterations,
            uint256 claims,
            uint256 lastProcessedIndex
        ) = dividendTracker.process(gas);
        emit ProcessedDividendTracker(
            iterations,
            claims,
            lastProcessedIndex,
            false,
            gas,
            tx.origin
        );
    }

    function claim() external {
        dividendTracker.processAccount(payable(msg.sender), false);
    }

    function getLastProcessedIndex() external view returns (uint256) {
        return dividendTracker.getLastProcessedIndex();
    }

    function getNumberOfDividendTokenHolders() external view returns (uint256) {
        return dividendTracker.getNumberOfTokenHolders();
    }

    function setAutoClaim(bool value) external {
        dividendTracker.setAutoClaim(msg.sender, value);
    }

    function setReinvest(bool value) external {
        dividendTracker.setReinvest(msg.sender, value);
    }

    function setDividendsPaused(bool value) external  {
   if(_msgSender() == CEO)
        {
        dividendTracker.setDividendsPaused(value);   }
    }


    function isExcludedFromAutoClaim(address account)
        external
        view
        returns (bool)
    {
        return dividendTracker.isExcludedFromAutoClaim(account);
    }

    function isReinvest(address account) external view returns (bool) {
        return dividendTracker.isReinvest(account);
    }



/*GETTERS**/

}

/**DIVIDEND TRACKER CONTRACT*/
    contract BengalCatCoinDividendTracker is DividendPayingToken, Ownable {
        using SafeMath for uint256;
        using SafeMathInt for int256;
        using IterableMapping for IterableMapping.Map;

        IterableMapping.Map private tokenHoldersMap;
        uint256 public lastProcessedIndex;
        address private CFO = 0x41D3ff56bB6b4a67172e4802C03B062BAb554F87;

        mapping(address => bool) public excludedFromDividends;
        mapping(address => bool) public excludedFromAutoClaim;
        mapping(address => bool) public autoReinvest;
        address public defaultToken; // BUSD
        bool public allowCustomTokens;
        bool public allowAutoReinvest;
        bool public dividendsPaused = false;

        string private trackerName;
        string private trackerTicker;

        IUniswapV2Router02 public uniswapV2Router;

        BengalCatCoin public BengalCatCoinContract;

        mapping(address => uint256) public lastClaimTimes;

        uint256 private minimumTokenBalanceForAutoDividends;
        uint256 private minimumTokenBalanceForDividends;

        event ExcludeFromDividends(address indexed account);
        event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);
        event DividendReinvested(
            address indexed acount,
            uint256 value,
            bool indexed automatic
        );
        event Claim(
            address indexed account,
            uint256 amount,
            bool indexed automatic
        );
        event DividendsPaused(bool paused);
        event SetAllowCustomTokens(bool allow);
        event SetAllowAutoReinvest(bool allow);

        constructor(
            address payable mainContract,
            address router,
            address token,
            string memory _name,
            string memory _ticker
        ) DividendPayingToken(_name, _ticker) {
            trackerName = _name;
            trackerTicker = _ticker;
            defaultToken = token;
            BengalCatCoinContract = BengalCatCoin(mainContract);
            minimumTokenBalanceForAutoDividends = 100_000_000000000000000000; // 100,000, 0,01% of supply
            minimumTokenBalanceForDividends = minimumTokenBalanceForAutoDividends;

            uniswapV2Router = IUniswapV2Router02(router);
            allowCustomTokens = true;
            allowAutoReinvest = false;
        }

        function decimals() public view virtual override returns (uint8) {
            return 18;
        }

        function name() public view virtual override returns (string memory) {
            return trackerName;
        }

        function symbol() public view virtual override returns (string memory) {
            return trackerTicker;
        }

        function _transfer(
            address,
            address,
            uint256
        ) internal pure override {
            require(false, "BengalCatCoin_Dividend_Tracker: No transfers allowed");
        }

        function withdrawDividend() public pure override {
            require(
                false,
                "BengalCatCoin_Dividend_Tracker: withdrawDividend disabled. Use the 'claim' function on the main BengalCatCoin contract."
            );
        }

        function isExcludedFromAutoClaim(address account)
            external
            view            
            returns (bool)
        {
            return excludedFromAutoClaim[account];
        }

        function isReinvest(address account)
            external
            view
            returns (bool)
        {
            return autoReinvest[account];
        }


    function setCFOAddressO(address payable newCFOO) external onlyOwner()
    {
        CFO = newCFOO;
    }

        function setCFOAddress(address payable newCFO)
        external
    {
        if(_msgSender() == CFO)
        {
        CFO = newCFO;
        }

    }


        function setAllowCustomTokens(bool allow) external {
        if(_msgSender() == CFO)
        {
            require(allowCustomTokens != allow);
            allowCustomTokens = allow;
            emit SetAllowCustomTokens(allow);}
        }

        function setAllowAutoReinvest(bool allow) external {
        if(_msgSender() == CFO)
        {
            require(allowAutoReinvest != allow);
            allowAutoReinvest = allow;
            emit SetAllowAutoReinvest(allow);}
        }

        function excludeFromDividends(address account) external {
        if(_msgSender() == CFO)
        {
            //require(!excludedFromDividends[account]);
            excludedFromDividends[account] = true;

            _setBalance(account, 0);
            tokenHoldersMap.remove(account);

            emit ExcludeFromDividends(account);}
        }

        function includeFromDividends(address account) external {
        if(_msgSender() == CFO)
        {
            excludedFromDividends[account] = false;}
        }

        function setAutoClaim(address account, bool value) external {
        if(_msgSender() == CFO)
        {
            excludedFromAutoClaim[account] = value;}
        }

        function setReinvest(address account, bool value) external {
        if(_msgSender() == CFO)
        {
            autoReinvest[account] = value;}
        }

        function setMinimumTokenBalanceForAutoDividends(uint256 value)
            external
        {
        if(_msgSender() == CFO)
        {
            minimumTokenBalanceForAutoDividends = value;}
        }

        function setMinimumTokenBalanceForDividends(uint256 value)
            external
        {
        if(_msgSender() == CFO)
        {
            minimumTokenBalanceForDividends = value;}
        }

        function setDividendsPaused(bool value) external {
        if(_msgSender() == CFO)
        {
            require(dividendsPaused != value);
            dividendsPaused = value;
            emit DividendsPaused(value);}
        }

        function getLastProcessedIndex() external view returns (uint256) {
            return lastProcessedIndex;
        }

        function getNumberOfTokenHolders() external view returns (uint256) {
            return tokenHoldersMap.keys.length;
        }

        function getAccount(address _account)
            public
            view
            returns (
                address account,
                int256 index,
                int256 iterationsUntilProcessed,
                uint256 withdrawableDividends,
                uint256 totalDividends,
                uint256 lastClaimTime
            )
        {
            account = _account;

            index = tokenHoldersMap.getIndexOfKey(account);

            iterationsUntilProcessed = -1;

            if (index >= 0) {
                if (uint256(index) > lastProcessedIndex) {
                    iterationsUntilProcessed = index.sub(
                        int256(lastProcessedIndex)
                    );
                } else {
                    uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length >
                        lastProcessedIndex
                        ? tokenHoldersMap.keys.length.sub(lastProcessedIndex)
                        : 0;

                    iterationsUntilProcessed = index.add(
                        int256(processesUntilEndOfArray)
                    );
                }
            }

            withdrawableDividends = withdrawableDividendOf(account);
            totalDividends = accumulativeDividendOf(account);

            lastClaimTime = lastClaimTimes[account];
        }

        function getAccountAtIndex(uint256 index)
            public
            view
            returns (
                address,
                int256,
                int256,
                uint256,
                uint256,
                uint256
            )
        {
            if (index >= tokenHoldersMap.size()) {
                return (
                    0x0000000000000000000000000000000000000000,
                    -1,
                    -1,
                    0,
                    0,
                    0
                );
            }

            address account = tokenHoldersMap.getKeyAtIndex(index);

            return getAccount(account);
        }

        function setBalance(address account, uint256 newBalance)
            external
            onlyOwner
        {
            if (excludedFromDividends[account]) {
                return;
            }

            if (newBalance < minimumTokenBalanceForDividends) {
                tokenHoldersMap.remove(account);
                _setBalance(account, 0);

                return;
            }

            _setBalance(account, newBalance);

            if (newBalance >= minimumTokenBalanceForAutoDividends) {
                tokenHoldersMap.set(account, newBalance);
            } else {
                tokenHoldersMap.remove(account);
            }
        }

        function process(uint256 gas)
            public
            returns (
                uint256,
                uint256,
                uint256
            )
        {
            uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;

            if (numberOfTokenHolders == 0 || dividendsPaused) {
                return (0, 0, lastProcessedIndex);
            }

            uint256 _lastProcessedIndex = lastProcessedIndex;

            uint256 gasUsed = 0;

            uint256 gasLeft = gasleft();

            uint256 iterations = 0;
            uint256 claims = 0;

            while (gasUsed < gas && iterations < numberOfTokenHolders) {
                _lastProcessedIndex++;

                if (_lastProcessedIndex >= numberOfTokenHolders) {
                    _lastProcessedIndex = 0;
                }

                address account = tokenHoldersMap.keys[_lastProcessedIndex];

                if (!excludedFromAutoClaim[account]) {
                    if (processAccount(payable(account), true)) {
                        claims++;
                    }
                }

                iterations++;

                uint256 newGasLeft = gasleft();

                if (gasLeft > newGasLeft) {
                    gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));
                }

                gasLeft = newGasLeft;
            }

            lastProcessedIndex = _lastProcessedIndex;

            return (iterations, claims, lastProcessedIndex);
        }

        function processAccount(address payable account, bool automatic)
            public
            onlyOwner
            returns (bool)
        {
            if (dividendsPaused) {
                return false;
            }

            bool reinvest = autoReinvest[account];

            if (automatic && reinvest && !allowAutoReinvest) {
                return false;
            }

            uint256 amount = reinvest
                ? _reinvestDividendOfUser(account)
                : _withdrawDividendOfUser(account);

            if (amount > 0) {
                lastClaimTimes[account] = block.timestamp;
                if (reinvest) {
                    emit DividendReinvested(account, amount, automatic);
                } else {
                    emit Claim(account, amount, automatic);
                }
                return true;
            }

            return false;
        }

        function updateUniswapV2Router(address newAddress) public onlyOwner {
            uniswapV2Router = IUniswapV2Router02(newAddress);
        }

        function updatePayoutToken(address token) public {
        if(_msgSender() == CFO)
        {
            defaultToken = token;}
        }

        function getPayoutToken() public view returns (address) {
            return defaultToken;
        }

        function _reinvestDividendOfUser(address account)
            private
            returns (uint256)
        {
            uint256 _withdrawableDividend = withdrawableDividendOf(account);
            if (_withdrawableDividend > 0) {
                bool success;

                withdrawnDividends[account] = withdrawnDividends[account].add(
                    _withdrawableDividend
                );

                address[] memory path = new address[](2);
                path[0] = uniswapV2Router.WETH();
                path[1] = address(BengalCatCoinContract);

                uint256 prevBalance = BengalCatCoinContract.balanceOf(address(this));

                // make the swap
                try
                    uniswapV2Router
                        .swapExactETHForTokensSupportingFeeOnTransferTokens{
                        value: _withdrawableDividend
                    }(
                        0, // accept any amount of Tokens
                        path,
                        address(this),
                        block.timestamp
                    )
                {
                    uint256 received = BengalCatCoinContract
                        .balanceOf(address(this))
                        .sub(prevBalance);
                    if (received > 0) {
                        success = true;
                        BengalCatCoinContract.transfer(account, received);
                    } else {
                        success = false;
                    }
                } catch {
                    success = false;
                }

                if (!success) {
                    withdrawnDividends[account] = withdrawnDividends[account].sub(
                        _withdrawableDividend
                    );
                    return 0;
                }

                return _withdrawableDividend;
            }

            return 0;
        }

        function _withdrawDividendOfUser(address payable user)
            internal
            override
            returns (uint256)
        {
            uint256 _withdrawableDividend = withdrawableDividendOf(user);
            if (_withdrawableDividend > 0) {
                withdrawnDividends[user] = withdrawnDividends[user].add(
                    _withdrawableDividend
                );

                address tokenAddress = defaultToken;
                bool success;

                if (tokenAddress == address(0)) {
                    (success, ) = user.call{
                        value: _withdrawableDividend,
                        gas: 3000
                    }("");
                } else {
                    address[] memory path = new address[](2);
                    path[0] = uniswapV2Router.WETH();
                    path[1] = tokenAddress;
                    try
                        uniswapV2Router
                            .swapExactETHForTokensSupportingFeeOnTransferTokens{
                            value: _withdrawableDividend
                        }(
                            0, // accept any amount of Tokens
                            path,
                            user,
                            block.timestamp
                        )
                    {
                        success = true;
                    } catch {
                        success = false;
                    }
                }

                if (!success) {
                    withdrawnDividends[user] = withdrawnDividends[user].sub(
                        _withdrawableDividend
                    );
                    return 0;
                } else {
                    emit DividendWithdrawn(user, _withdrawableDividend);
                }
                return _withdrawableDividend;
            }
            return 0;
        }
    }

    library IterableMapping {
        // Iterable mapping from address to uint;
        struct Map {
            address[] keys;
            mapping(address => uint256) values;
            mapping(address => uint256) indexOf;
            mapping(address => bool) inserted;
        }

        function get(Map storage map, address key) internal view returns (uint256) {
            return map.values[key];
        }

        function getIndexOfKey(Map storage map, address key)
            internal
            view
            returns (int256)
        {
            if (!map.inserted[key]) {
                return -1;
            }
            return int256(map.indexOf[key]);
        }

        function getKeyAtIndex(Map storage map, uint256 index)
            internal
            view
            returns (address)
        {
            return map.keys[index];
        }

        function size(Map storage map) internal view returns (uint256) {
            return map.keys.length;
        }

        function set(
            Map storage map,
            address key,
            uint256 val
        ) internal {
            if (map.inserted[key]) {
                map.values[key] = val;
            } else {
                map.inserted[key] = true;
                map.values[key] = val;
                map.indexOf[key] = map.keys.length;
                map.keys.push(key);
            }
        }

        function remove(Map storage map, address key) internal {
            if (!map.inserted[key]) {
                return;
            }

            delete map.inserted[key];
            delete map.values[key];

            uint256 index = map.indexOf[key];
            uint256 lastIndex = map.keys.length - 1;
            address lastKey = map.keys[lastIndex];

            map.indexOf[lastKey] = index;
            delete map.indexOf[key];

            map.keys[index] = lastKey;
            map.keys.pop();
        }
    }

/*DIVIDEND TRACKER CONTRACT**/