/**
 *Submitted for verification at BscScan.com on 2022-05-22
*/

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNKkdlc::;;:cldk0NMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNOd:'.             .'ckNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMXkdc'                      ,xNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNOl'                            cXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMXx;.       .,:ldxkkkxo:.           lNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMXd'      .'lkKWMMMMMMMMMMXx'         .kMMMMMMMMMMMMWXOxddxkKWMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMXd.     .cOKNMMMMMMMMMMMMMMMMX:         cNMMMMMMMMMXd;.      .,oXMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNd'     ,dXMMMMMMMMMMMMMMMMMMMMMK,        ;XMMMMWNK0d,  .:odol,.  .xWMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNk,    .:kNMMMMMMMMMMMMMMMMMMMMMMMWl        'xkdlc,'.   .cKWMMMMNk'  .kMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMW0:    .c0WMMMMMMMMMMMMMMMMMMMMMMMMMWl                    ;XMMMMMMMMd.  :NMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMXo.   .c0WMMMMMMMMMMMMMMMMMMMMMMMMMWNO'                    ,KMMMMMMMWo   cNMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWk,   .c0WMMMMMMMMMMMMMMMMMMMMMMMWKko;'.                  .   ;ONMMMWXo.  .kMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMKc.   :0WMMMMMMMMMMMMMMMMMMMMMWKxl,.            .,:lodxkOO00k;  .,:cc;.   ,kWMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNx'   ,kNMMMMMMMMMMMMMMMMMMMMN0o;.      .        ,OWMMMMMMMMMMMNk:'.     .:xXMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMKc.  .dXMMMMMMMMMMMMMMMMMMMW0o,.     .,:;.      .dXMMMMMMMMMMMMMMMWN0kxxk0XWMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWk'  .cKWMMMMMMMMMMMMMMMMWWXx;.     .:dxo,      .lKWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMXl.  'kWMMMMMMMMMMMMMMMMW0l;.     'lkKOl.      .l0WMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWO,  .cKMMMMMMMMMMMMMMMMNk;.     .lONXx;.      .oKWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNd.  'kWMMMMMMMMMMMMMMMNx,      ,xXXkc.       ,dXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMKc   :KMMMMMMMMMMMMMMMWO;     'cdkd:.       .cONMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMWO,  .oNMMMMMMMMMMMMMMMNd.      .,'.       .:xXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMNx.  'kWMMMMMMMMMMMMMMMWx.               .:xXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMNl.  ;0MMMMMMMMMMMMMMMMMMd.           .;lkXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMK:   cXMMMMMMMMMMMMMMMMMMMNx;....';codOXWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMW0,  .oNMMMMMMMMMMMMMMMMMMMMMMWNXXNWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMWk.  .dWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMWx.  .kWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMNd.  .OWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMNl.  'OWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMXc   'OWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMX:   'OWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMK;   .OWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMM0,   .xWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMW0,   .dWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMWO'    cNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMWk.    ;KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMWk.    .kMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMWx.     oWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMWx.     ;KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMWx.     .kMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMWx.      cNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMWx.      .OMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMWx.       lWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMWk.       '0MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMK,        oWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMx.       ,KMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMk.      ,OWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMWk:,';cxXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMWWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
                                                                                                    
// SPDX-License-Identifier: MIT

pragma solidity ^0.5.17;

// Interface of a token BEP20 - ERC20 - TRC20 - .... All functions of the standard interface are declared, even if not used
interface TOKEN20 {
    function totalSupply() external view returns (uint);
    function balanceOf(address tokenOwner) external view returns (uint balance);
    function allowance(address tokenOwner, address spender) external view returns (uint remaining);
    function transfer(address to, uint tokens) external returns (bool success);
    function approve(address spender, uint tokens) external returns (bool success);
    function transferFrom(address from, address to, uint tokens) external returns (bool success);
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}

// Interface to the external Tunnel contract (triggers used to send money to external contract). Only used function is declared
interface TunnelContract {
    // Trigger function used for token transfer + action (must limit gas). userID and packageID can be used to share data about the purchase
    function triggerFunction(address token_addr, uint amount, uint userID, uint16 packageID, string calldata descID) external returns(bool outcome);
}

// Interface for the external custom threshold/eligibility for the package and/or for the commissions
interface ExternalEligibilityContract {
    // Function use to check the eligibility (eg. custom Token/NFT/other thresholds or other logics) 
    function isEligibleExt(address user_address, address other_address, uint16 packageID, uint param1, int param2, uint8 sourceID) external view returns (bool is_eligible);
}


// Define the abstract contract for an ownable contract with transfer ownership (requires accept) and modifier for owner only functions
contract Ownable
{
    address public ownerWallet;     // The wallet Owner
    address private newOwner;        // The wallet new Owner (before confirmation)

    event OwnershipTransferredEv(address indexed previousOwner, address indexed newOwner);

    constructor() public
    {
        //Set contract owner
        ownerWallet = msg.sender;
    }

    function transferOwnership(address _newOwner) public onlyOwner
    {
        // Set the new owner, but this needs confirmation from the new owner (accept ownership)
        newOwner = _newOwner;
    }

    function acceptOwnership() public
    {
        // Only new owner can accept the ownership transfer
        require(msg.sender == newOwner);
        emit OwnershipTransferredEv(ownerWallet, newOwner);
        ownerWallet = newOwner;
        newOwner = address(0);
    }

    // Modifier to be used with functions that can be called only by owner
    modifier onlyOwner()
    {
        require(msg.sender == ownerWallet, "Denied");
        _;
    }

}


// MAIN CONTRACT
contract Powermade is Ownable {

    // Constants
    address public constant address_zero = address(0);      // The address(0)
    address public constant headPlaceholder = address(1);   // Address associated to the ID1 as placeholder. Real coins go to headWallet     
    uint8 public constant maxDownLimit = 5;     // Max number of direct spots under a user (first level downline)
    uint8 private constant maxCommissionFailedAttempts = maxDownLimit * 2;          // Max number of failed distribution attempts for the dynamic compression (when banned or not active)
    uint private constant coin_unit = 1e18;      // A coin unit (18 decimals)
    uint private constant max_iterations = maxDownLimit + maxDownLimit**2 + maxDownLimit**3;    // Max iterations for the placement algorithm - 3 full levels
    uint private constant max_expand_index = maxDownLimit + maxDownLimit**2 - 1;    // Max index (included) for the spotFinder function, for the expansion of the downline

    // Global Variables
    address public token_addr;              // Address of the used token (eg. BUSD token)  
    uint public lastIDCount = 0;            // Last ID of the matrix (1 to last). This is also the number of users
    uint private PIDcount = 0;              // Purchase unique ID identifier/counter
    address public projectWallet;           // Wallet where to send the project fee (50%). It can be changed
    address public tunnelContract;          // External smart contract that can accept money for other business automations
    address public headWallet;              // Wallet linked to the head, the ID1 destination for commissions, aka Team One
    address private approveWallet;          // Wallet used to only ban/unban (eg. for KYC approvals)
    address private pricingWallet;          // Wallet that can change the prices of the packages (eg. automated price settings)
    mapping(address => bool) public enabled_contracts;    // Contracts enabled to call BuyPackageExt() function or receive the tunnel (tunnelContract)
    bool public bannedLogic = true;         // Logic associated to banned variable (true means that banned=true is banned)
    bool public businessEnabled = true;     // Globally enable the smart contract (BuyPackage from users, the BuyPackageExt is still available, managed by the caller)
    bool private entered = false;           // Use to protect from reentrancy (used in payTunnel20)

    // Data structures

    // A USER (PLAYER)
    struct userStructure {
        uint id;                                // The ID. If user exists the ID is >0
        uint referrerID;                        // native ID who referred the User (sponsor)
        uint virtualID;                         // REAL upline for the User (due to forced matrix system, after placement)
        uint[] invitedIDs;                      // dynamic array with invited users (IDs). Length is directly_invited. Length is number of invited
        uint[] downlineIDs;                     // array of downline IDs, can be max 5 (forced matrix). Length is the number of directs
        uint32 round_robin_next_index;          // Next index (of downlineIDs) to add to the round_robin when one gets deleted, starts from maxDownLimit (5) 
        mapping(uint => uint) round_robin;      // round robin memory for the spillover distribution
        bool banned;                            // Used to ban (disable) the user
        uint totalEarned;                       // Total earned for the user (all Packages)
        mapping(uint16 => userPackageData) packagesData;      // Data related to a particular Package
        uint[] bought_packages_array;           // Array of ALL bought packages - PID references (timeline)
    }

    // Information about a particular package from the perspective of a player
    struct userPackageData {
        uint[] bought_array;        // Array with PIDs of bought packages. Last element is the most recent. Length is the Number of time this package has been bought is
        uint totalEarnedPack;       // Total BUSD earned from downline related to the selling activity on this package
    }

    // Purchase structure (store data of a purchase)
    struct PurchaseInfo {
        uint userID;                // Player who bought the package
        uint16 packageID;           // ID of the package (first package is the mandatory package)
        uint timestamp;             // Purchase Timestamp in s
        uint duration;              // saved duration associated to this package (at the buy time)
    }

    // A PACKAGE (service/product, like a course category or a subscription)
    struct packageStructure {
        uint price;                         // Price in BUSD cents (1e18). Package exists if > 0 (price always > 0.001)
        uint duration;                      // Duration in seconds. 0 means never expires (one-shot)
        int32 available_units;              // The number of available units (0 means that the Package cannot be purchased anymore, -1 means infinite)
        bool enabled;                       // Status of the package. If disabled it cannot be bought/activated
        bool rebuy_enabled;                 // Enable rebuy of the package (subscription mode)
        bool rebuy_before_exp;              // Enable rebuy before expiration (concurrent subscription mode). Used only when rebuy_enabled and saved duration > 0
        uint16[] prerequisites;             // Required packages (except 1) to unlock (allow to buy) this package
        bool prereq_not_exp;                // Define if expiration (bought TS + duration) must be checked before buy, in case of a prerequisite with saved duration > 0
        uint16[] commission_per_level;      // Commissions for each level. 8 elements, the first is for the sponsor, other 5 (maxDownLimit) for the upline (down to up), then the royalty (can be 0) and the last is the tunnel (can be 0)
        address royalty_address;            // The recipient of the royalty (if it exists)
        address eligibility_sc_address;     // The associate external eligibility checker (if used must be not address(0))
    }

    // Database (global mappings and arrays)
    mapping(uint16 => packageStructure) public packagesIndex;       // Storage for the packages profiles
    uint16[] public addedPackages;                                  // Storage for the IDs of the added packages (packageID can be arbitrary code)
    mapping(uint => address) public userIDaddress;                  // Storage for mapping the user IDs to related addresses (structure)
    mapping(address => userStructure) public userInfos;             // The matrix
    mapping(uint => PurchaseInfo) public purchasesList;             // Storage for the purchases (access with PID)

    // Events 
    event UserRegistrationEv(uint32 indexed timestamp_hour, uint32 indexed timestamp_days, uint userID, address userAddr);
    event PurchasePackageEv(uint32 indexed timestamp_hour, uint32 indexed timestamp_days, uint userID, uint16 packageID, uint PID);
    event PaidUplineEv(uint indexed user, uint16 indexed packageID, uint tot_amount_upline, uint tot_amount_remaining, uint tot_amount_royalty, uint tot_amount_project);
    event ChangedBanStatusEv(uint indexed user, bool indexed new_status, bool logic);        
    event ChangedApproveStatusEv(uint indexed user, bool indexed new_status, bool logic);  
    event AddEditPackageEv(uint16 indexed packageID, uint price, bool is_new_add);
    event ChangedFeatureParameterEv(string indexed tag);    // Indexed strings are saved as keccak256(string)


    // Constructor called when deploying
    constructor(address _token_addr, address _projectWallet, address _headWallet) public {
        ownerWallet = msg.sender;
        changeTokenUsed(_token_addr);
        changeBusinessWallets(_projectWallet, address(0), _headWallet, address(0), address(0));
        // Create the head. Parameters not set are the default ones (eg. 0, false, empty array...)
        lastIDCount = 1;
        userIDaddress[1] = headPlaceholder;
        userInfos[headPlaceholder].id = 1;
        userInfos[headPlaceholder].banned = !bannedLogic;
        userInfos[headPlaceholder].round_robin_next_index = maxDownLimit;
        emit UserRegistrationEv(uint32(block.timestamp/3600), uint32(block.timestamp/86400), 1, headPlaceholder);
        // --------
        // Set the default commission percentages (divider is 1000) - using packageID=0 (not a valid packageID) as storage
        // index 0 : commission for the sponsor (who invites)
        // index 1 to index MaxDownLimit (5) : commissions for the uplines (parents) going up from the payer
        // index MaxDownLimit+1 : royalty percentage (if any)
        // index MaxDownLimit+2 : tunnel to external contract (if any)
        // The remaining percentage is the project Fee sent to the project wallet directly
        // The Business percentage is intended to be composed by royalty + tunnel + remaining
        packagesIndex[0].commission_per_level = [100, 100, 90, 80, 60, 70, 0, 0];
        // --------
        // Create the BASE (mandatory) package. Prices are in BUSD (the token_addr is expected to be BUSD)
        uint16[] memory empty_array;
        _addEditPackage(1, true, -1, 179, false, false, 0, false, false, empty_array, false);   // Mandatory

        // USEFUL - DEBUG TO REMOVE IN MAINNET VERSION
        _addEditPackage(2, true, -1, 600, false, false, 0, false, false, empty_array, false);
        _addEditPackage(3, true, -1, 1180, false, false, 0, false, false, empty_array, false);
        _addEditPackage(4, true, -1, 1750, false, false, 0, false, false, empty_array, false);
    }


    // Register a new user (by buying packageID 1) using the given sponsorID. Or Buy a generic Package (after registration) with the given PackageID (sponsor is ignored, hierarchy is defined by the registration).
    // Some packages can be rebought, some have an expiration, some are hybrid, depending on the added packages.
    // Commissions are paid to the sponsor and the upline levels, a part goes to the project wallet.
    // EXTERNAL Function called by the user to register itself or to buy a package for itself
    function BuyPackage(uint sponsorID, uint16 packageID) external {
        require(businessEnabled, "GlobalEN");
        require(msg.sender == tx.origin, "OriginE");
        buyPackageInt(msg.sender, sponsorID, packageID, true);
    }


    // Function used to call the BuyPackage from an external allowed contract, to integrate further features with the main contract (integrations)
    // The function bypasses the businessEnabled flag, that must be managed by the caller (eg. reading the flag from this contract if needed)
    function BuyPackageExt(address userAddr, uint sponsorID, uint16 packageID, bool pay_commissions) external {
        // Allow access only to enabled smart contracts
        require(isContract(msg.sender) && enabled_contracts[msg.sender], "Denied");
        buyPackageInt(userAddr, sponsorID, packageID, pay_commissions);
    }


    // Register a new user (by buying packageID 1) using the given sponsorID. Or Buy a generic Package (after registration) with the given PackageID (sponsor is ignored, hierarchy is defined by the registration).
    // Some packages can be rebought, some have an expiration, some are hybrid, depending on the added packages.
    // Commissions are paid to the sponsor and the upline levels, a part goes to the project wallet.
    // This is the INTERNAL function used to register a generic user address passed to the function
    function buyPackageInt(address userAddr, uint sponsorID, uint16 packageID, bool pay_commissions) private {
        require(!isContract(userAddr), "SCNA");
        require(userAddr != ownerWallet && userAddr != headWallet && userAddr != projectWallet && userAddr != headPlaceholder && userAddr != approveWallet && userAddr != pricingWallet, "Denied");
        // The package must be enabled
        require(packagesIndex[packageID].enabled, "PackD");
        // -------------
        // If the user is new, package 1 is required to buy. The sponsor is associated to the user and the player placed into the matrix
        if (userInfos[userAddr].id == 0) {
            require(sponsorID <= lastIDCount && sponsorID > 0, "SponsID");
            require(packageID == 1, "Pack1E");
            // Place the user in the matrix, using the algorithm 
            placeNewUser(userAddr, userIDaddress[sponsorID]);
            emit UserRegistrationEv(uint32(block.timestamp/3600), uint32(block.timestamp/86400), userInfos[userAddr].id, userAddr);
        }
        // -------------
        // Checks before buying the package...
        // User is not banned
    	require(!isBanned(userAddr), "UserBD");
        // The package must be available
        require(packagesIndex[packageID].available_units != 0, "SoldOut");
        // Check if rebuy is active and user already bought. discriminate between cases with and without expiration check
        uint n_bought = userInfos[userAddr].packagesData[packageID].bought_array.length;
        if (n_bought > 0) {
            require(packagesIndex[packageID].rebuy_enabled, "RebuyD");
            uint last_pid = userInfos[userAddr].packagesData[packageID].bought_array[n_bought-1];
            if (purchasesList[last_pid].duration > 0 && block.timestamp < purchasesList[last_pid].timestamp + purchasesList[last_pid].duration) {
                // Last purchase of the same packageID not expired!
                require(packagesIndex[packageID].rebuy_before_exp, "RebuybeD");
            }
        }
        // Check prerequisites of the package
        for (uint8 i = 0; i < packagesIndex[packageID].prerequisites.length; i++) {
            // Package must me already bought (at least once, if the prerequisite is a package that allows rebuy)
            uint16 currentPrerequisite = packagesIndex[packageID].prerequisites[i];
            require(userInfos[userAddr].packagesData[currentPrerequisite].bought_array.length > 0, "PrereqMiss");
            uint n_bought_rereq = userInfos[userAddr].packagesData[currentPrerequisite].bought_array.length;
            uint last_pid_prereq = userInfos[userAddr].packagesData[currentPrerequisite].bought_array[n_bought_rereq-1];
            // If the check of expiration (not expired) is enabled and the prerequisite has an expiration, it must not be expired to buy the source packageID
            if (packagesIndex[packageID].prereq_not_exp && purchasesList[last_pid_prereq].duration > 0) {
                require(block.timestamp <= purchasesList[last_pid_prereq].timestamp + purchasesList[last_pid_prereq].duration, "PrereqExp");
            }
        }
        // Eternal eligibility check (eg. token/NFT quantity)
        if (packagesIndex[packageID].eligibility_sc_address != address(0)) {
            require(ExternalEligibilityContract(packagesIndex[packageID].eligibility_sc_address).isEligibleExt(userAddr, userIDaddress[sponsorID], packageID, n_bought, 0, 1), "ExtChk");
        }
        // ----------------
        // Buy the package and pay the commissions
        // Reduce the available units
        if (packagesIndex[packageID].available_units > 0) {
            packagesIndex[packageID].available_units--;
        }
        // Create the purchase
        PurchaseInfo memory purchase = PurchaseInfo({
            userID: userInfos[userAddr].id,
            packageID: packageID,
            timestamp: block.timestamp,
            duration: packagesIndex[packageID].duration
        });
        PIDcount++;
        purchasesList[PIDcount] = purchase;
        // Update user data
        userInfos[userAddr].bought_packages_array.push(PIDcount);
        userInfos[userAddr].packagesData[packageID].bought_array.push(PIDcount);
        emit PurchasePackageEv(uint32(block.timestamp/3600), uint32(block.timestamp/86400), userInfos[userAddr].id, packageID, PIDcount);
        // Transfer the money (tokens) to the contract
        if (pay_commissions) {
            depositTokenContract(packagesIndex[packageID].price);
            // Distribute the payment (commissions and project wallet)
            payCommissions(userAddr, packageID);
        }
    }


    // Pay the commissions to the network and the project business. Update the earning statistics for the players/packages.
    // SafeMath library not used, because the code is written to ensure that overflow/underflow is impossible (packet prices are always > 0.01 sum of commission percentages is checked to be 1000 in the setter admin function. Project fee is always > 1)
    function payCommissions(address payer, uint16 packageID) private {
        uint amount = packagesIndex[packageID].price;
        uint unpaid = amount;
        uint remaining = 0;
        // First send the commission to the sponsor
        address sponsor = userIDaddress[userInfos[payer].referrerID];
        uint toPay = amount*packagesIndex[packageID].commission_per_level[0]/1000;
        if (isEligibleReceiveCommissions(sponsor, packageID, payer, 0, 2)) {
            payUser20(sponsor, toPay);
            userInfos[sponsor].totalEarned += toPay;
            userInfos[sponsor].packagesData[packageID].totalEarnedPack += toPay;
            unpaid -= toPay;
        } else {
            remaining += toPay;     // Not paid, so it's a remaining
        }
        // Distribute levels with dynamic compression (up to maxCommissionFailedAttempts failed level payouts)
        {
            uint failed_attempts = 0;
            // Pay the upline, climbing parent by parent, for max 5 levels
            address currentUplineAddr = userIDaddress[userInfos[payer].virtualID];
            for (uint8 i = 1; i <= maxDownLimit; i++) {
                toPay = amount*packagesIndex[packageID].commission_per_level[i]/1000;
                if (currentUplineAddr == address(0)) {
                    // The level is above the head, so it's a remaining
                    remaining += toPay;
                } else {    
                    // Pay the level if not banned and still active (package 1 not expired, only if configured in subscription mode)
                    if (isEligibleReceiveCommissions(currentUplineAddr, packageID, payer, i, 3)) {
                        payUser20(currentUplineAddr, toPay);
                        userInfos[currentUplineAddr].totalEarned += toPay;
                        userInfos[currentUplineAddr].packagesData[packageID].totalEarnedPack += toPay;
                        unpaid -= toPay;
                    } else {
                        failed_attempts++;
                        if (failed_attempts < maxCommissionFailedAttempts) {
                            // Freeze the for index (do the next cycle again, but with the parent, keeping the current commission level)
                            i--; 
                        } else {
                            remaining += toPay;     // Not paid, so it's a remaining
                        }  
                    }
                }
                // Go up to parent
                currentUplineAddr = userIDaddress[userInfos[currentUplineAddr].virtualID];
            }
        }
        // Pay the remaining to the Head (ID 1)
        if (remaining > 0) {
            payUser20(headPlaceholder, remaining);
            userInfos[headPlaceholder].totalEarned += remaining;
            userInfos[headPlaceholder].packagesData[packageID].totalEarnedPack += remaining;
            unpaid -= remaining;
        }
        toPay = unpaid;     // use unused toPay variable to store the current unpaid, before royalty and tunnel. This is the "project amount" (remaining excluded)
        // Pay the royalty if configured. The royalty is still considered part of the "project amount" of the company, but instantly paid to the contractor
        if (packagesIndex[packageID].royalty_address != address(0) && packagesIndex[packageID].commission_per_level[maxDownLimit+1] > 0) {
            uint royalty_amount = 0;
            royalty_amount = amount*packagesIndex[packageID].commission_per_level[maxDownLimit+1]/1000;
            unpaid -= royalty_amount;
            payUser20(packagesIndex[packageID].royalty_address, royalty_amount);
            emit PaidUplineEv(userInfos[payer].id, packageID, amount-toPay-remaining, remaining, royalty_amount, toPay);
        } else {
            emit PaidUplineEv(userInfos[payer].id, packageID, amount-toPay-remaining, remaining, 0, toPay);
        }
        // Pay the tunnel if enabled and available, otherwise ignore this percentage and consider it part of the unpaid to tend to the projectWallet. The tunnel is still considered part of the "project amount" of the company
        if (packagesIndex[packageID].commission_per_level[maxDownLimit+2] > 0 && enabled_contracts[tunnelContract]) {
            uint tunnel_amount = 0;
            tunnel_amount = amount*packagesIndex[packageID].commission_per_level[maxDownLimit+2]/1000;
            unpaid -= tunnel_amount;
            ////// SEND money out of the tunnel (with reentrant protection)
            require(!entered, "Reent");
            entered = true;
            // Do the token transfer to the tunnel contract (money will be already there when executing the triggerFunction)
            payUser20(tunnelContract, tunnel_amount);
            // Call the trigger function
            bool success = TunnelContract(tunnelContract).triggerFunction(token_addr, tunnel_amount, userInfos[payer].id, packageID, "PowermadeMain");
            require(success, "TCErr");
            entered = false;
        }
        // Pay the unpaid to the projectWallet
        payUser20(projectWallet, unpaid);
        userInfos[projectWallet].totalEarned += unpaid;
    }


    // Check if a user is banned
    function isBanned(address userAddr) internal view returns (bool is_banned) {
        is_banned = bannedLogic ? userInfos[userAddr].banned : !userInfos[userAddr].banned;
    }

    // Check if a user is eligible to receive the commissions
    function isEligibleReceiveCommissions(address userAddr, uint16 packageID, address payer, uint level, uint8 sourceID) internal view returns (bool is_eligible) {
        // Check for package 1 expiration (when subscription mode is used)
        uint packageOnePurchasesCount = userInfos[userAddr].packagesData[1].bought_array.length;
        uint lastPackageOnePID = userInfos[userAddr].packagesData[1].bought_array[packageOnePurchasesCount-1];
        uint duration = purchasesList[lastPackageOnePID].duration;
        bool expired = duration > 0 ? ( block.timestamp > purchasesList[lastPackageOnePID].timestamp + duration ? true : false ) : false;
        bool is_ext_eligible = true;
        // Eternal Eligibility check (if enabled)
        if (packagesIndex[packageID].eligibility_sc_address != address(0)) {
            is_ext_eligible = ExternalEligibilityContract(packagesIndex[packageID].eligibility_sc_address).isEligibleExt(userAddr, payer, packageID, level, expired ? 1 : 0, sourceID);
        }
        is_eligible = !isBanned(userAddr) && !expired && is_ext_eligible;
    }


    // Place the new user during the registration. This uses a hybrid placement system: for the first 5 invited users the placement occurs in the sponsor sub-structure (sub-matrix). 
    // After the 5 (maxDownLimit) invited users, a round-robin system is used, targeting the sub-structures of each of the first 5 invited people as starting point for the placement. 
    // For every new user, the next invited user (of the 5) is used as target, in a circular way, restarting from the the first invited user after the 5th.
    // The search for a free spot (placement) works only for the first 3 levels in the targeted sub-structure, if there are no free spots, the user is added under the last one that joined the smart contract (last ID). 
    // If a sub-structure associated to an invited user is full, the user is deleted from the round-robin circular list (5 elements) and replaced with a new invited user that is not yet in the list. For example the 6th invited user.
    function placeNewUser(address addr, address sponsorAddr) private {
        // Create the user
        lastIDCount++;
        userIDaddress[lastIDCount] = addr;
        userInfos[addr].id = lastIDCount;
        userInfos[addr].banned = !bannedLogic;
        userInfos[addr].referrerID = userInfos[sponsorAddr].id;
        userInfos[addr].round_robin_next_index = maxDownLimit;
        // Find the free spot... And place the user            
        // If we have less than maxDownLimit ALREADY INVITED users, we use the spotFinder search, from the sponsor, limited to 3 levels
        uint invitedCount = userInfos[sponsorAddr].invitedIDs.length;
        if (invitedCount < maxDownLimit) {
            (uint insertionID, address insertionAddr) = spotFinder(sponsorAddr);
            if (insertionID > 0) {
                // Place the user under the insertionID
                userInfos[insertionAddr].downlineIDs.push(lastIDCount);
                userInfos[addr].virtualID = insertionID;
            } else {
                // If spaces are full, use the last added user as upline
                userInfos[addr].virtualID = lastIDCount - 1;        // We already increased the count
                userInfos[userIDaddress[lastIDCount-1]].downlineIDs.push(lastIDCount);
            }
            // Update the sponsor data
            userInfos[sponsorAddr].invitedIDs.push(lastIDCount);
            userInfos[sponsorAddr].round_robin[invitedCount+1] = lastIDCount;
        // If we already have maxDownLimit invited users or more, use the round robin placement
        } else {
            // Scan the round robin memory and place search for a free spot in the affiliation structure of the invited players, round-robin order
            uint candidateID = userInfos[sponsorAddr].round_robin[invitedCount-maxDownLimit+1];
            (uint insertionID, address insertionAddr) = spotFinder(userIDaddress[candidateID]);
            if (insertionID > 0) {
                // Place the user under the insertionID
                userInfos[insertionAddr].downlineIDs.push(lastIDCount);
                userInfos[addr].virtualID = insertionID;
                // Update round robin memory to next: keep the same, there are still spots
                userInfos[sponsorAddr].round_robin[invitedCount+1] = candidateID;
            } else {
                // If spaces are full, use the last added user as upline
                userInfos[addr].virtualID = lastIDCount - 1;        // We already increased the count
                userInfos[userIDaddress[lastIDCount-1]].downlineIDs.push(lastIDCount);
                // Update round robin memory to next: move to the next invited user, discarding the full one (already has a decent structure), round_robin_next_index++
                userInfos[sponsorAddr].round_robin[invitedCount+1] = userInfos[sponsorAddr].invitedIDs[userInfos[sponsorAddr].round_robin_next_index];
                userInfos[sponsorAddr].round_robin_next_index++;
            }
            // Update the remaining sponsor data
            userInfos[sponsorAddr].invitedIDs.push(lastIDCount);
        }
    }

    // Search a free spot in the sub-structure (matrix) of the given user, considering the first 3 levels of the hierarchy. If there are no spots available, returns 0.
    function spotFinder(address referenceAddr) public view returns (uint insertionID, address insertionAddr) {
        // If the lv1 downline has free spots, place the user there and we have done
        if (userInfos[referenceAddr].downlineIDs.length < maxDownLimit) {
            return (userInfos[referenceAddr].id, referenceAddr);
        }
        // Search a spot in the first 3 level from the reference
        uint[] memory search_space = new uint[](max_iterations);
        for (uint8 i = 0; i < maxDownLimit; i++) {
            search_space[i] = userInfos[referenceAddr].downlineIDs[i];
        }
        for (uint16 i = 0; i < max_iterations; i++) {
            if (userInfos[userIDaddress[search_space[i]]].downlineIDs.length >= maxDownLimit) {
                // User is full
                // allocate the downline users for future search, if there is space in the search_space, then continue the search
                if (i <= max_expand_index) {
                    for (uint8 j = 0; j < maxDownLimit; j++) {
                        search_space[(i+1)*maxDownLimit+j] = userInfos[userIDaddress[search_space[i]]].downlineIDs[j];
                    }
                }
            } else {
                // There is a free spot under this user! This will be the insertionID!
                insertionID = search_space[i];
                insertionAddr = userIDaddress[search_space[i]];
                return (insertionID, insertionAddr);
            }
        }
        // Reached the end of the for cycle and not returned yet... So all spots are full!
        // In this case we return insertionID = 0 (not valid ID) and the caller function will manage the condition
        return (0, address(0));
    }



    // Internal function to manage the payment of a user, P2P, with the token
    function payUser20(address user, uint amount) private {
            // Case of the user is the head
            if (user == headPlaceholder) {
                user = headWallet;
            }
            // Pay the commission directly (direct transfer). 
            // Token Transfer
            bool success = TOKEN20(token_addr).transfer(user, amount);      // Do the token transfer
            require(success, "T20Err");
    }


    // Utility function to send a token to the smart contract balance
    // The transaction must be approved externally (in JS frontend) with 
    // token_addr.approve(smart_contract, amount)
    function depositTokenContract(uint amount) private {
        require(amount > 0, "Amount0");
        bool success = TOKEN20(token_addr).transferFrom(msg.sender, address(this), amount);
        require(success, "T20Err");
    }


    // Fallback function
    function () external payable {
        // Prevent users from using the fallback function to send money
        revert('Not Allowed!');
    }


    // Check if an address is a Smart Contract
    function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }



    // ------------ Admin Functions -------------



    // Change the wallets used for the business costs, head code (associated to the head placeholder) and approve Wallet
    function changeBusinessWallets(address newProjectWallet, address newTunnelContract, address newHeadWallet, address newApproveWallet, address newPricingWallet) public onlyOwner {
        if (newProjectWallet != address(0)) {
            projectWallet = newProjectWallet;
            emit ChangedFeatureParameterEv("ProjW");
        }
        if (newTunnelContract != address(0)) {
            require(enabled_contracts[newTunnelContract], "TCnotE");
            tunnelContract = newTunnelContract;
            emit ChangedFeatureParameterEv("TunC");
        }
        if (newHeadWallet != address(0)) {
            headWallet = newHeadWallet;
            emit ChangedFeatureParameterEv("HeadW");
        }
        if (newApproveWallet != address(0)) {
            approveWallet = newApproveWallet;
            emit ChangedFeatureParameterEv("ApprW");
        }
        if (newPricingWallet != address(0)) {
            pricingWallet = newPricingWallet;
            emit ChangedFeatureParameterEv("PricW");
        }
    }


    // Change the token used for the contract (default a stablecoin like BUSD)
    function changeTokenUsed(address token_used) public onlyOwner {
        require(token_used != address(0) && isContract(token_used), "InvAddr");
        token_addr = token_used;
        emit ChangedFeatureParameterEv("Token");
    }


    // Extract tokens from the contract (sent to the contract for mistake. There should not be tokens stored into this contract!)
    function retriveTokensContract(address token, uint amount, address destination) external onlyOwner {
        bool success = TOKEN20(token).transfer(destination, amount);      // Do the token transfer. The source is the contract itself
        require(success, "T20Err");
    }


    // Enable or disable the external contracts that can call the BuyPackageExt function or receive a tunnel (tunnelContract) with the triggerFunction
    function enableDisableExtContract(address external_contract, bool status) external onlyOwner {
        require(external_contract != address(0) && isContract(external_contract), "InvAddr");
        enabled_contracts[external_contract] = status;
        emit ChangedFeatureParameterEv("EnExtSC");
    }


    // Change the commission percentages end project percentages. Every percentage (except the tunnel_percentage and the royalty_percentage) must be > 0 and the sum must be 100 otherwise the transaction is rejected. 
    // Owner must define the invited (directly invited) percentage, the 5 level (upline) percentages, the royalty_percentage and the tunnel_percentage. The remaining percentage must be the project percentage, that is the percentage sent to the projectWallet.
    // If the tunnel_percentage is set to 0, it means that the tunnel feature is disabled. To be fully enabled there must be also a tunnelContract address set and enabled, otherwise the percentage set will be sent the projectWallet too.
    // If the royalty_percentage is set to 0 or the royalty_address is address(0), it means that the royalty feature is disabled and the percentage, if set, will be sent the projectWallet too.
    // To change the default percentages for every new package use the packageID = 0
    function changePackagePercentages(uint16 packageID, uint16 invited_percentage, uint16[] calldata commission_percentages, uint16 tunnel_percentage, uint16 project_percentage, uint16 royalty_percentage, address royalty_address) external onlyOwner {
        require(invited_percentage > 0 && project_percentage > 0, "Vals");
        packagesIndex[packageID].commission_per_level[0] = invited_percentage;
        uint16 sum_perc = invited_percentage + project_percentage+tunnel_percentage+royalty_percentage;
        for (uint8 i = 0; i < maxDownLimit; i++) {
            require(commission_percentages[i] > 0, "Vals");
            packagesIndex[packageID].commission_per_level[i+1] = commission_percentages[i];
            sum_perc += commission_percentages[i];
        }
        packagesIndex[packageID].commission_per_level[maxDownLimit+1] = royalty_percentage;
        packagesIndex[packageID].commission_per_level[maxDownLimit+2] = tunnel_percentage;
        packagesIndex[packageID].royalty_address = royalty_address;
        require(sum_perc == 1000, "Vals");
        emit ChangedFeatureParameterEv("Percent");
    }


    // Enable or disable user interaction with the smart contract (Write)
    function enableBusiness(bool enable) external onlyOwner {
        businessEnabled = enable;
        emit ChangedFeatureParameterEv("GlobEn");
    }


    // Change ban settings and/or ban/unban users
    function banUnban(bool changeBannedLogic, bool newBannedLogic, bool banUnbanUser, uint userID, bool newBanStatus) external onlyOwner {
        // Banned logic change
        if (changeBannedLogic) {
            bannedLogic = newBannedLogic;
            emit ChangedFeatureParameterEv("BanLogic");
        }
        // Ban/Unban the user
        if (banUnbanUser) {
            require(userID > 1 && userID < lastIDCount, "userID");     // Can ban existing users except head
            userInfos[userIDaddress[userID]].banned = newBanStatus;
            emit ChangedBanStatusEv(userID, newBanStatus, bannedLogic);
        }
    }


    // Function used by approveWallet to ban/unban only (eg. KYC approval if needed in the future)
    function approveUnapprove(uint userID, bool newBanStatus) external {
        // Can be called only by approveWallet
        require(msg.sender == approveWallet, "Denied");
        require(userID > 1 && userID < lastIDCount, "userID");     // Can ban existing users except head
        userInfos[userIDaddress[userID]].banned = newBanStatus;
        emit ChangedApproveStatusEv(userID, newBanStatus, bannedLogic);
    }


    // Add a package or edit an existing package. Packages can only be added or edited - Full configuration by Owner
    function addEditPackage(uint16 packageID, bool enabled, int32 available_units, uint price, bool price_is_cents, bool change_only_price_availability, uint duration, bool rebuy_enabled, bool rebuy_before_exp, uint16[] calldata prerequisites, bool prereq_not_exp) external onlyOwner {
        return _addEditPackage(packageID, enabled, available_units, price, price_is_cents, change_only_price_availability, duration, rebuy_enabled, rebuy_before_exp, prerequisites, prereq_not_exp);
    }


    // Add a package or edit an existing package. Packages can only be added or edited
    function _addEditPackage(uint16 packageID, bool enabled, int32 available_units, uint price, bool price_is_cents, bool change_only_price_availability, uint duration, bool rebuy_enabled, bool rebuy_before_exp, uint16[] memory prerequisites, bool prereq_not_exp) private {
        require(packageID > 0, "packID");
        if (!price_is_cents) {
            price = price * coin_unit;
        }
        require(price > coin_unit/1000, "Price <= 0.001");
        // Check if it's new or exists, add to the array if new
        if (packagesIndex[packageID].price == 0) {
            addedPackages.push(packageID);
            emit AddEditPackageEv(packageID, price, true);
        } else {
            emit AddEditPackageEv(packageID, price, false);
        }
        require(rebuy_before_exp ? rebuy_enabled : true, "Conf");
        // Add/edit parameters
        if (change_only_price_availability) {
            require(packagesIndex[packageID].price > 0, "PackEx");
            packagesIndex[packageID].price = price;
            packagesIndex[packageID].available_units = available_units;
            packagesIndex[packageID].enabled = enabled;
        } else {
            packageStructure memory newPackage = packageStructure({
                price: price,
                duration: duration,
                available_units: available_units,
                enabled: enabled,
                rebuy_enabled: rebuy_enabled,
                rebuy_before_exp: rebuy_before_exp,
                prerequisites: prerequisites,
                prereq_not_exp: prereq_not_exp,
                commission_per_level: packagesIndex[0].commission_per_level,    // Default percentages
                royalty_address: address(0),
                eligibility_sc_address: address(0)
            });
            packagesIndex[packageID] = newPackage;
        }
    }


    // Change the price, the availability and the Token Threshold of a Package. Only the price, enabled, available_units, unlock_token_address and unlock_token_amount can be changed.
    // Callable only by the price manager address, the owner or an enabled smart contract
    function changePackageCommercial(uint16 packageID, uint price, bool price_is_cents, bool enabled, int32 available_units, address eligibility_sc_address) external {
        require(msg.sender == pricingWallet || msg.sender == ownerWallet || enabled_contracts[msg.sender], "Denied");
        uint16[] memory empty_array;
        _addEditPackage(packageID, enabled, available_units, price, price_is_cents, true, 0, false, false, empty_array, false);
        // Extra configuration: Token threshold feature. The Package can be bought only if the user owns at least N tokens in the wallet. Set address(0) or amount 0 to disable
        require(eligibility_sc_address == address(0) || isContract(eligibility_sc_address), "Addr");
        packagesIndex[packageID].eligibility_sc_address = eligibility_sc_address;
        emit ChangedFeatureParameterEv("PackComm");
    }



    // ------------ View Functions -------------


    // Return information associated to a given packageID (default percentages are stored in the packageID number 0). If an optional (>0) userID is given, it returns also the total earned amount, the number of purchases and the last PID for the packageID for that userID (otherwise these variables will be 0)
    function getPackageInfo(uint16 packageID, uint userID) public view returns (uint price, uint duration, bool enabled, bool rebuy_enabled, bool rebuy_before_exp, uint16[] memory prerequisites, uint16[] memory percentages, bool prereq_not_exp, uint totalEarnedPack, uint purchasesCount, uint last_pid) {
        price = packagesIndex[packageID].price;         // Price == 0 means the package does not exists and all read data should be null/default. 0 is not a real package.
        duration = packagesIndex[packageID].duration;
        enabled = packagesIndex[packageID].enabled;
        rebuy_enabled = packagesIndex[packageID].rebuy_enabled;
        rebuy_before_exp = packagesIndex[packageID].rebuy_before_exp;
        prereq_not_exp = packagesIndex[packageID].prereq_not_exp;
        prerequisites = packagesIndex[packageID].prerequisites;
        percentages = packagesIndex[packageID].commission_per_level;
        if (userID > 0) {
            require(userID <= lastIDCount, "userID");
            totalEarnedPack = userInfos[userIDaddress[userID]].packagesData[packageID].totalEarnedPack;
            purchasesCount = userInfos[userIDaddress[userID]].packagesData[packageID].bought_array.length;
            if (purchasesCount > 0) {
                last_pid = userInfos[userIDaddress[userID]].packagesData[packageID].bought_array[purchasesCount-1];
            }
        }
    }


    // Scan the added packages array in chunks and return information related to the packages
    function getAddedPackagesMainInfo(uint start_index, uint stop_index) external view returns (uint16[] memory packageID, uint[] memory price, uint[] memory duration, bool[] memory enabled, bool[] memory rebuy_enabled, int32[] memory available_units, bool[] memory has_prerequisites) {
        require(stop_index >= start_index, "Index");
        if (stop_index >= addedPackages.length) {
            stop_index = addedPackages.length - 1;
        }
        packageID = new uint16[](stop_index-start_index+1);
        price = new uint[](stop_index-start_index+1);
        duration = new uint[](stop_index-start_index+1);
        enabled = new bool[](stop_index-start_index+1);
        rebuy_enabled = new bool[](stop_index-start_index+1);
        available_units = new int32[](stop_index-start_index+1);
        has_prerequisites = new bool[](stop_index-start_index+1);
        for (uint i = start_index; i <= stop_index; i++) {
            uint16[] memory prerequisites;
            uint16[] memory commissions_per_level;
            packageID[i] = addedPackages[i];
            available_units[i] = packagesIndex[addedPackages[i]].available_units;
            (price[i], duration[i], enabled[i], rebuy_enabled[i], , prerequisites, commissions_per_level, , , , ) = getPackageInfo(addedPackages[i], 0);
            has_prerequisites[i] = (prerequisites.length > 0);
        }
    }


    // Scan the added packages array in chunks and return information related to the packages but related to a particular userID: userID-related info is total earned, number of purchases, last purchase PID, last purchase timestamp and expiration
    function getAddedPackagesUserInfo(uint userID, uint start_index, uint stop_index) external view returns (uint16[] memory packageID, uint16[] memory network_percentage, uint[] memory totalEarnedPack, uint[] memory purchasesCount, uint[] memory last_PID, uint[] memory last_timestamp, bool[] memory last_expired) {
        require(stop_index >= start_index, "Index");
        require(userID > 0, "userID");
        if (stop_index >= addedPackages.length) {
            stop_index = addedPackages.length - 1;
        }
        packageID = new uint16[](stop_index-start_index+1);
        totalEarnedPack = new uint[](stop_index-start_index+1);
        purchasesCount = new uint[](stop_index-start_index+1);
        last_PID = new uint[](stop_index-start_index+1);
        last_timestamp = new uint[](stop_index-start_index+1);
        last_expired = new bool[](stop_index-start_index+1);
        network_percentage = new uint16[](stop_index-start_index+1);
        for (uint i = start_index; i <= stop_index; i++) {
            packageID[i] = addedPackages[i];
            uint16[] memory commissions_per_level;
            (, , , , , , commissions_per_level, , totalEarnedPack[i], purchasesCount[i], last_PID[i]) = getPackageInfo(addedPackages[i], userID);
            if (last_PID[i] > 0) {
                ( , , last_timestamp[i], , last_expired[i]) = getPurchaseInfo(last_PID[i]);
            }  
            network_percentage[i] = commissions_per_level[0];
            for (uint8 j = 1; j <= maxDownLimit; j++) {
                network_percentage[i] += commissions_per_level[j];
            }
        }
    }


    // Return the information of a purchaseID, included the expiration flag
    function getPurchaseInfo(uint purchaseID) public view returns (uint userID, uint16 packageID, uint timestamp, uint duration, bool expired) {
        require(purchaseID > 0 && purchaseID <= PIDcount, "PIDEx");
        userID = purchasesList[purchaseID].userID;
        packageID = purchasesList[purchaseID].packageID;
        timestamp = purchasesList[purchaseID].timestamp;
        duration = purchasesList[purchaseID].duration;
        expired = duration > 0 ? ( block.timestamp > timestamp + duration ? true : false ) : false;
    }


    // Return the purchases information in chunks. Depending on the input parameters it can return the global purchase list (eg. to calculate the income of the business), the purchases of the userID or the purchases of the userID but for a given packageID (eg. in the case of packages that can be rebought).
    // In the case of the global purchases list, the PID is (i+1) where i is the index of the returned data (from start to stop index, that is count_all-1 at maximum).
    // In the other cases the userID is an input argument, known, so we return the PIDs instead of the userIDs.
    function getAllPurchases(uint userID, uint16 packageID, uint start_index, uint stop_index, bool only_last) external view returns (uint count_all, uint[] memory userIDs_or_PIDs, uint16[] memory packageIDs, uint[] memory timestamps, uint[] memory durations, bool[] memory expireds) {
        // If userID = 0 get from the global purchase list
        // If userID is a valid user, and packageID = 0, get from the user bought list
        // If userID is a valid user and packageID a valid package, get from the bought list of that user for that package
        require(stop_index >= start_index, "Index");
        if (userID == 0) {
            count_all = PIDcount;
        } else {
            require(userID <= lastIDCount, "userID");
            if (packageID == 0) {
                count_all = userInfos[userIDaddress[userID]].bought_packages_array.length;
            } else {
                require(packagesIndex[packageID].price > 0, "PackEx");
                count_all = userInfos[userIDaddress[userID]].packagesData[packageID].bought_array.length;
            }
        }
        if (count_all > 0) {
            // Only last element option
            if (only_last) {
                start_index = count_all - 1;
                stop_index = start_index;
            }
            // Coerce to length of the list if needed
            if (stop_index >= count_all) {
                stop_index = count_all - 1;
            }
            userIDs_or_PIDs = new uint[](stop_index-start_index+1);
            packageIDs = new uint16[](stop_index-start_index+1);
            timestamps = new uint[](stop_index-start_index+1);
            durations = new uint[](stop_index-start_index+1);
            expireds = new bool[](stop_index-start_index+1);
            // Populate the arrays depending on the case
            if (userID == 0) {
                for (uint i = start_index; i <= stop_index; i++) {
                    (userIDs_or_PIDs[i], packageIDs[i], timestamps[i], durations[i], expireds[i]) = getPurchaseInfo(i+1);
                }
            } else if (packageID == 0) {
                uint[] memory purchases_array = userInfos[userIDaddress[userID]].bought_packages_array;
                for (uint i = start_index; i <= stop_index; i++) {
                    ( , packageIDs[i], timestamps[i], durations[i], expireds[i]) = getPurchaseInfo(purchases_array[i]);
                    userIDs_or_PIDs[i] = purchases_array[i];
                }
            } else {
                uint[] memory purchases_array = userInfos[userIDaddress[userID]].packagesData[packageID].bought_array;
                for (uint i = start_index; i <= stop_index; i++) {
                    ( , packageIDs[i], timestamps[i], durations[i], expireds[i]) = getPurchaseInfo(purchases_array[i]);
                    userIDs_or_PIDs[i] = purchases_array[i];
                }
            }
        }
    }


    // Get the information about a given user, using either the address or the ID. If a packageID is given, also some information related to the package are returned (for the given user). Invited users are returned in chunks. 
    // The function returns also the global information of the smart contract and can be called with ID1 for this purpose.
    // For details about how data is organized in the return arrays, see the comments inside the function code. 
    function getUsersInfos(address tUserAddr, uint tUserID, uint16 packageID, uint invited_start_index, uint invited_stop_index) external view returns (uint[] memory globals, address[] memory addresses, uint[] memory IDs, uint[] memory counts, uint[] memory amounts, bool banned) {
        // Can use the user address or the user ID as reference. If tUserID is 0, the address will be used
        if (tUserID > 0) {
            tUserAddr = userIDaddress[tUserID];
        } else {
            if (tUserAddr == headWallet) {
                tUserAddr = headPlaceholder;
            }
            tUserID = userInfos[tUserAddr].id;
        }
        require(tUserID > 0 && tUserID <= lastIDCount, "userID");
        // Id a packageID > 0 is passed, the functions returns also the user date related to the particular package (eg. number of purchases, earnings)
        if (packageID > 0) {
            require(packageID <= PIDcount, "packID");
        }
        // List of invited users can be returned in chunks
        require(invited_stop_index >= invited_start_index, "Index");      // Check on user given parameters
        if (userInfos[tUserAddr].invitedIDs.length == 0) {
            // Case of empty array
            invited_stop_index = 0;
            invited_start_index = 1;
        } else if (invited_stop_index >= userInfos[tUserAddr].invitedIDs.length) {
            // Coerce
            invited_stop_index = userInfos[tUserAddr].invitedIDs.length - 1;
        }
        // Create arrays
        globals = new uint[](5);
        addresses = new address[](8+1+1+invited_stop_index-invited_start_index);
        IDs = new uint[](8+1+1+invited_stop_index-invited_start_index);
        counts = new uint[](4);
        amounts = new uint[](2);
        // Global information: N_users | N_purchases | N_added_packages | BusinessEnabled | Network % (current packageID)
        globals[0] = lastIDCount;
        globals[1] = PIDcount;
        globals[2] = addedPackages.length;
        globals[3] = businessEnabled ? 1 : 0;
        globals[4] = packagesIndex[packageID].commission_per_level[0];
        for (uint8 j = 1; j <= maxDownLimit; j++) {
            globals[4] += packagesIndex[packageID].commission_per_level[j];
        }
        // Counts: N_invited | N_downline | N_purchases | N_purchases(PackageID)
        counts[0] = userInfos[tUserAddr].invitedIDs.length;
        counts[1] = userInfos[tUserAddr].downlineIDs.length;
        counts[2] = userInfos[tUserAddr].bought_packages_array.length;
        counts[3] = userInfos[tUserAddr].packagesData[packageID].bought_array.length;
        // Amounts: totalEarned | totalEarned(packageID)
        amounts[0] = userInfos[tUserAddr].totalEarned;
        amounts[1] = userInfos[tUserAddr].packagesData[packageID].totalEarnedPack;
        banned = bannedLogic ? userInfos[tUserAddr].banned : !userInfos[tUserAddr].banned;
        // IDs : royaltyID (if exists) | userID | sponsorID | uplineID | DownlineIDs (5 elements, 0 if missing) | InvitedIDs (dynamic)
        // Addresses: the addresses associated to the above IDs (if royalty is an external address, the ID will be 0)
        IDs[0] = userInfos[packagesIndex[packageID].royalty_address].id;
        IDs[1] = tUserID;
        IDs[2] = userInfos[tUserAddr].referrerID;
        IDs[3] = userInfos[tUserAddr].virtualID;
        addresses[0] = packagesIndex[packageID].royalty_address;
        addresses[1] = userIDaddress[IDs[0]];
        addresses[2] = userIDaddress[IDs[1]];
        addresses[3] = userIDaddress[IDs[2]];
        // maxDownLimit fixed spots for the downline (0 means the spot is free)
        for (uint8 i = 4; i < maxDownLimit + 4; i++) {
            if (i >= userInfos[tUserAddr].downlineIDs.length + 4) {
                IDs[i] = 0;
                addresses[i] = address(0);
            } else {
                IDs[i] = userInfos[tUserAddr].downlineIDs[i-4];
                addresses[i] = userIDaddress[IDs[i]];
            }
        }
        for (uint i = invited_start_index; i <= invited_stop_index; i++) {
            IDs[i+9] = userInfos[tUserAddr].invitedIDs[i];
            addresses[i+9] = userIDaddress[IDs[i+9]];
        }
    }

    
    ///////////////////////////////// Debug functions

    // Function used to debug the Round Robin memory. Can be removed in main-net version
    function roundRobinDebug(uint userID, uint elemID) external view returns (uint invitedCount, uint32 round_robin_next_index, uint round_robin_val) {
        invitedCount = userInfos[userIDaddress[userID]].invitedIDs.length;
        round_robin_next_index =  userInfos[userIDaddress[userID]].round_robin_next_index;
        round_robin_val =  userInfos[userIDaddress[userID]].round_robin[elemID];
    }


}