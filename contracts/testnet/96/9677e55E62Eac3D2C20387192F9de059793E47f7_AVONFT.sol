/**
 *Submitted for verification at BscScan.com on 2021-09-16
*/

/*
Публичное соглашение
с пользователями настоящего смартконтракта и общие правила пользования

Единственным правообладателем и владельцем настоящего смартконтракта созданного в блокчейн сети Binanse Smart Chain в соответствии с протоколом BEP 1155 является юридическое лицо созданное и зарегистрированное в соответствии с законодательством Российской Федерации с организационно-правовой формой общество с ограниченной ответственностью (ООО) «ПраймТайм», идентификационный номер налогоплательщика ИНН 5003136048, основной государственный регистрационный номер (ОГРН) 1195027021375
 Настоящий смартконтракт создан с целью генерации NFT (non-fungible token) содержащих удостоверенные сведения об исключительных правах на результаты интеллектуальной деятельности, а также об условиях правомерного их использования в том числе смены правообладателя, а также смарт контракт выполняет функцию генерации эскроу контрактов для обеспечения безопасных сделок по перепродажи NFT  токенов на вторичном рынке.
Настоящий смартконтракт является неотъемлемой частью комплекса программных средств объединенных в рамках проекта «АвокадоНФТ» («AvocadoNFT»)
Информация о проекте «АвокадоНФТ» («AvocadoNFT») размещена на официальных сайтах проекта AvocadoNFT.com, AvocadoNFT.ru, AvocadoNFT.club, AvoNFT.io
Все правоотношения авторов и правообладателей по поводу владения, пользования и распоряжения исключительными правами на результаты интеллектуальной деятельности регулируются в соответствии с российским и международным правом, а также настоящим соглашением с пользователями, а также соглашениями и правилами, изложенными на официальных сайтах проекта «АвокадоНФТ».
ООО «ПраймТайм» в соответствии с гражданским законодательством РФ является информационным посредником в соответствии с юридическим определение данным в статье 1253.1 Гражданского кодекса Российской Федерации обеспечивающим.
Передача исключительных прав на результаты интеллектуальной деятельности от правообладателя получателю производится на основании письменного договора в соответствии с статьей 1234 Гражданского кодекса Российской Федерации.
В соответствии со статьей 434 Гражданского кодекса РФ договор в письменной форме может быть заключен путем обмена электронными документами либо иными данными в соответствии с правилами абзаца второго пункта 1 статьи 160 Гражданского кодекса Российской Федерации.
Сторонами договора о передаче исключительных прав на результаты интеллектуальной деятельности являются лица предоставившие сведения о своем уникальном адресе криптокошелька, через которые производятся расчеты, то есть на криптокошелек правообладателя зачисляются криптоактитивы  в обмен на NFT   токен который зачисляется на криптокошелек Получателя исключительных прав на результаты интеллектуальной деятельности.
 Лицом, выразившим волю к совершению сделки в смысле статьи 161 Гражданского кодекса Российской Федерации, то есть подписавшим договор на передачу исключительных прав на результаты интеллектуальной деятельности  признается лицо предоставившее уникальный адрес криптокошелька и правомерно владеющее и распоряжающееся любым программным средством предоставляющим доступ к информации и возможностью управления данной информацией размещенной на данном уникальном адресе криптокошелька.
Стороны соглашаются с тем, что сделка считается возмездной (в смысле изложенном в части 3 статьи 1234 Гражданского кодекса Российской Федерации) в связи с тем, что в обмен на  NFT токен Правообладатель получает токен AVO (проекта Авокадо НФТ) либо с его согласия и возможности любой другой криптоактив. Размер вознаграждения определяется сторонами в момент заключения сделки путем удостоверения согласия со сделкой и ее акцептом произведенным в электронной форме таким технологическим способом который позволяет совершить данную сделку.
Стороны понимают и соглашаются с тем, что исключительные права на результаты интеллектуальной деятельности, правомерно выраженные и закрепленные в NFT   токене, передаются по факту передачи данного NFT токена от Правообладателя Получателю в том объеме и на тех условиях, которые закреплены в данном NFT токене.
Передача NFT токена осуществляется путем списания данного NFT    токена с уникального адреса криптокошелька Праообладателя и зачисления данного  NFT  токена на уникальный адрес Получателя.
Ни одна из сторон настоящего соглашения не несет ответственности за неправомерное завладение уникальным адресом криптокошелька и средствами доступа к нему. Правообладатель уникального адреса криптокошелька несет самостоятельную ответственность за конфиденциальную информацию, предоставляющую доступ к его криптокошельку.
Пользователи настоящего смартконтракта самостоятельно несут ответственность за правомерность своих действий.
ООО «ПраймТайм» не несет ответственности за неправомерные действия пользователей настоящего смартконтракта.
Пользователи настоящего смартконтракта несут самостоятельную ответственность за ознакомление с условиями настоящего смарт контракта и последствиями, которые могут наступить в случае отсутствия у пользователя информации, изложенной в настоящем соглашении.
Пользователи настоящего контракта несут гражданскую, административную и уголовную ответственность за нарушение исключительных прав на результаты интеллектуальной деятельности в соответствии с международным и российским законодательством.
Ознакомление с настоящим соглашением и отсутствие у пользователя возражений, выраженных в письменной форме и удостоверенных в нотариальной форме до начала пользования настоящим контрактом и другими програмными продуктами проекта “АвокадоНФТ” считается пониманием и принятием всех условий и определений, выраженных в настоящем соглашении, а также всеми соглашениями в рамках проекта «АвокадоНФТ».
Начало пользования  настоящим смартконтрактом считается пониманием и принятием всех условий и определений, выраженных в настоящем соглашении, а также всеми соглашениями в рамках проекта «АвокадоНФТ».
*/

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;


library Address {

    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize, which returns 0 for contracts in
        // construction, since the code is only stored at the end of the
        // constructor execution.

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly { size := extcodesize(account) }
        return size > 0;
    }

    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value
        (bool success, ) = recipient.call{ value: amount }("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }


    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
      return functionCall(target, data, "Address: low-level call failed");
    }


    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }


    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }


    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.call{ value: value }(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }


    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }


    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.staticcall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }


    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }


    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return _verifyCallResult(success, returndata, errorMessage);
    }

    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                // solhint-disable-next-line no-inline-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}


/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);

    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);
}


/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}


abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


    constructor (address initialOwner) {
        _owner = initialOwner;
        emit OwnershipTransferred(address(0), initialOwner);
    }


    function owner() public view virtual returns (address) {
        return _owner;
    }


    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }


    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }


    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}


interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}


abstract contract ERC165 is IERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}



interface IERC1155 is IERC165 {

    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);

    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);

    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    event URI(string value, uint256 indexed id);

    function balanceOf(address account, uint256 id) external view returns (uint256);

    function balanceOfBatch(address account, uint256[] calldata ids) external view returns (uint256[] memory);

    function setApprovalForAll(address operator, bool approved) external;

    function isApprovedForAll(address account, address operator) external view returns (bool);

    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;

    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;
}


interface IERC1155Receiver is IERC165 {

    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    )
        external
        returns(bytes4);


    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    )
        external
        returns(bytes4);
}


interface IERC1155MetadataURI is IERC1155 {

    function uri(uint256 id) external view returns (string memory);
}


/**
 * @dev _Available since v3.1._
 */
abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);
    }
}



library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}


interface IAVOERC20 is IERC20 {
    function addReward (uint256 amount) external returns (bool);
}


contract AVONFT is Context, ERC165, IERC1155, IERC1155MetadataURI, Ownable, ERC1155Receiver {
    using Address for address;
    using SafeERC20 for IAVOERC20;
    using SafeERC20 for IERC20;

    struct NFTToken {
        uint256 authorID;
        address broker;
        uint256 authorRoyalty;
        uint256 brokerRoyalty;
        uint256 platformRoyalty;
        uint256 tokenSupply;
        uint256 price;
        string  ipfsHASH;
    }

    struct Author {
        address wallet;
        uint8 status;
    }

    mapping (uint256 => NFTToken) public _tokens;
    mapping (uint256 => Author) public _authors;
    mapping (address => uint256) public _authorIds;
    mapping (address => address) public _referrals;

    // Mapping from token ID to account balances
    mapping(uint256 => mapping(address => uint256)) internal _balances;
    // Mapping from account to operator approvals
    mapping(address => mapping(address => bool)) internal _operatorApprovals;

    mapping(address => mapping(address => mapping(uint256 => uint256))) internal _tokenApprovals;

    mapping (address => bool) public _isBanned;

    mapping (uint256 => uint256[]) private _authorsTokens;

    uint256 public currentTokenId;

    uint256 public currentAuthorId;

    uint256 private _referralPercent;

    uint256 private _communityDistributionPercent;

    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json
    string public _baseURI;

    address public avoERC20Contract;
 
    constructor(address cOwner) Ownable(cOwner) {
        _baseURI = "";
    }


    modifier onlyMinter() {
        require((owner() == _msgSender() || _authorIds[_msgSender()] != 0), "Caller is not the minter");
        _;
    }


    function exists(uint256 _id) internal view returns(bool) {
        if (_tokens[_id].authorID == 0) {
            return false;
        } else {
            return true;
        }
    }


    function isAuthor(address _account) public view returns(bool) {
        if (_authorIds[_account] == 0) {
            return false;
        } else {
            return true;
        }
    }


    function setBaseURI(string memory _newuri) public onlyOwner {
        _baseURI = _newuri;
    }

    function uri(uint256 _id) public view virtual override returns (string memory) {
        require(exists(_id), "Token doesn't exist");
        return string(abi.encodePacked(_baseURI, _tokens[_id].ipfsHASH));
    }


    function totalSupply(uint256 _id) public view returns (uint256) {
        require(exists(_id), "Token doesn't exist");
        return _tokens[_id].tokenSupply;
    }

    function create (
        uint256 initialSupply,
        uint256 price,
        string memory ipfsHASH,
        address author,
        address broker,
        uint256 authorRoyalty,
        uint256 brokerRoyalty,
        uint256 platformRoyalty
      ) external onlyMinter returns (uint256) {
        if (_msgSender() == owner()) {
            require(author != address(0), "Zero address for author is prohibited");
            require(_authorIds[author] != 0, "This author is not registered");
        } else {
            author = _msgSender();
        }
        require(!_isBanned[_msgSender()], "User is banned");
        require(initialSupply > 0, "Cannot create zero amount of tokens");
        require(authorRoyalty + brokerRoyalty + platformRoyalty <= 80, "Total royalty cannot exceed 80%");
        uint256 _id = currentTokenId + 1;
        _mint(address(this), _id, initialSupply, "");
        NFTToken memory newToken = NFTToken({
                                                authorID: _authorIds[author],
                                                broker: broker,
                                                authorRoyalty: authorRoyalty,
                                                brokerRoyalty: brokerRoyalty,
                                                platformRoyalty: platformRoyalty,
                                                tokenSupply: initialSupply,
                                                price: price,
                                                ipfsHASH: ipfsHASH
                                            });


        _tokens[_id] = newToken;
        currentTokenId++;
        _authorsTokens[_authorIds[author]].push(_id);
        return _id;
      }


    function recoverERC20(address _token, address _to) external onlyOwner {
        uint256 balance = IERC20(_token).balanceOf(address(this));
        require(balance > 0, "No tokens to transfer");
        IERC20(_token).safeTransfer(_to, balance);
    }

    function recoverBNB(address payable _to) external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No BNB to transfer");
        (bool sent, ) = _to.call{value: balance, gas: 50000}("");
        require(sent, "Failed to send BNB payment to owner");
    }


    function banUser(address _account) external onlyOwner {
        require(!_isBanned[_account], "Address is already banned");
        _isBanned[_account] = true;
    }

    function unbanUser(address _account) external onlyOwner {
        require(_isBanned[_account], "Address is not banned");
        _isBanned[_account] = false;
    }

    function setERC20Token(address _account) external onlyOwner {
        require((_account != address(0) && _account.isContract()), "Invalid contract address");
        avoERC20Contract = _account;
    }

    function registerAuthor(address _account, uint8 _status) external onlyOwner returns(uint256) {
        require(_account != address(0), "Invalid author address");
        require(_status <= 3, "Invalid status value");
        require(_authorIds[_account] == 0, "Author is already registered");
        uint256 _id = currentAuthorId + 1;
        Author memory newAuthor = Author({
                                                wallet: _account,
                                                status: _status
                                            });


        _authors[_id] = newAuthor;
        _authorIds[_account] = _id;
        currentAuthorId++;
        return _id;
    }

    function changeAuthorStatus(address _account, uint8 _status) external onlyOwner {
        require(_status <= 3, "Invalid status value");
        require(_account != address(0), "Invalid author address");
        require(_authorIds[_account] != 0, "Author is not registered");
        require(_authors[_authorIds[_account]].status != _status, "Author already has this status");
        _authors[_authorIds[_account]].status = _status;
    }

    function changeAuthorStatus(uint256 _id, uint8 _status) external onlyOwner {
        require(_status <= 3, "Invalid status value");
        require(_authors[_id].wallet != address(0), "No author is registered under this id");
        require(_authors[_id].status != _status, "Author already has this status");
        _authors[_id].status = _status;
    }

    function setAuthorWallet(uint256 _id, address _account) external onlyOwner {
        require(_account != address(0), "Invalid wallet address");
        require(_authors[_id].wallet != address(0), "No author is registered under this id");
        _authorIds[_authors[_id].wallet] = 0;
        _authorIds[_account] = _id;
        _authors[_id].wallet = _account;
    }

    function getAuthor(uint256 _id) public view returns (address, uint8) {
        return (_authors[_id].wallet, _authors[_id].status);
    }

    function getAuthorID(address _account) public view returns (uint256, uint8) {
        return (_authorIds[_account], _authors[_authorIds[_account]].status);
    }

    function getTokenPrice(uint256 _id) public view returns(uint256) {
        require(exists(_id), "Token doesn't exist");
        return _tokens[_id].price;
    }

    function getReferralPercent() public view returns(uint256) {
        return _referralPercent;
    }

    function getPlatformRoyalty(uint256 _id) public view returns(uint256) {
        require(exists(_id), "Token doesn't exist");
        return _tokens[_id].platformRoyalty;
    }

    function getCommunityDistribution() public view returns(uint256) {
        return _communityDistributionPercent;
    }

    function setReferralPercent(uint256 _percent) external onlyOwner {
        require(_percent < 100, "Percentage cannot exceed 100%");
        _referralPercent = _percent;
    }

    function setCommunityDistribution(uint256 _percent) external onlyOwner {
        require(_percent < 100, "Percentage cannot exceed 100%");
        _communityDistributionPercent = _percent;
    }

    function getTokensByAuthorID(uint256 _id) public view returns (uint256[] memory) {
        require(_authors[_id].wallet != address(0), "Author doesn't exist");
        uint256[] memory result = new uint256[](_authorsTokens[_id].length);
        for (uint i = 0; i < _authorsTokens[_id].length; i++) {
          result[i] = _authorsTokens[_id][i];
        }
        return result;
    }

    function approve(address _spender, uint256 _id, uint256 _amount) public {
        require(exists(_id), "Token doesn't exist");
        _tokenApprovals[_msgSender()][_spender][_id] = _amount;
    }


    function primaryBuyNFT(uint256 _id, uint256 _amount, address _ref) public {
        primaryBuyNFT(_msgSender(), _id, _amount, _ref);
    }

    function primaryBuyNFT(address _account, uint256 _id, uint256 _amount, address _ref) internal {
        require(exists(_id), "Token doesn't exist");
        require(!_isBanned[_account], "User is banned");
        require(avoERC20Contract != address(0), "AVO ERC20 contract is not set");
        require(balanceOf(address(this), _id) >= _amount, "Insufficient NFT token amount to buy");
        if (_referrals[_account] != address(0)) {
            _ref = _referrals[_account];
        } else if (_ref != address(0)) {
            _referrals[_account] = _ref;
        }
        uint256 totalAmount = _amount * _tokens[_id].price;
        IAVOERC20(avoERC20Contract).safeTransferFrom(_account, address(this), totalAmount);
        _safeTransferFrom(address(this), _account, _id, _amount, "");
        uint256 refRoyalty;
        uint256 pRoyalty;
        uint256 bRoyalty;
        uint256 distribution;
        if (_ref != address(0)) {
            refRoyalty = totalAmount * _referralPercent / 100;
            IAVOERC20(avoERC20Contract).safeTransfer(_ref, refRoyalty);
        }
        if (_tokens[_id].broker != address(0) && _tokens[_id].brokerRoyalty > 0) {
            bRoyalty = totalAmount * _tokens[_id].brokerRoyalty / 100;
            IAVOERC20(avoERC20Contract).safeTransfer(_tokens[_id].broker, bRoyalty);
        }
        if (_tokens[_id].platformRoyalty > 0) {
            pRoyalty = totalAmount * _tokens[_id].platformRoyalty / 100;
            distribution = pRoyalty * _communityDistributionPercent / 100;
            if (distribution > 0) {
                IAVOERC20(avoERC20Contract).safeApprove(avoERC20Contract, distribution);
                IAVOERC20(avoERC20Contract).addReward(distribution);
            }
            IAVOERC20(avoERC20Contract).safeTransfer(owner(), pRoyalty - distribution);
        }
        IAVOERC20(avoERC20Contract).safeTransfer(_authors[_tokens[_id].authorID].wallet, totalAmount - refRoyalty - pRoyalty - bRoyalty);
    }

    function secondaryBuyNFT(address _tokenOwner, uint256 _id, uint256 _amount, address _ref) public {
        secondaryBuyNFT(_msgSender(), _tokenOwner, _id, _amount, _ref);
    }


    function secondaryBuyNFT(address _account, address _owner, uint256 _id, uint256 _amount, address _ref) internal {
        require(exists(_id), "Token doesn't exist");
        require(!_isBanned[_account], "User is banned");
        require(avoERC20Contract != address(0), "AVO ERC20 contract is not set");
        require(balanceOf(_owner, _id) >= _amount, "Insufficient NFT token amount to buy");
        if (_referrals[_account] != address(0)) {
            _ref = _referrals[_account];
        } else if (_ref != address(0)) {
            _referrals[_account] = _ref;
        }
        uint256 totalAmount = _amount * _tokens[_id].price;
        IAVOERC20(avoERC20Contract).safeTransferFrom(_account, address(this), totalAmount);
        _safeTransferFrom(_owner, _account, _id, _amount, "");
        uint256 refRoyalty;
        uint256 pRoyalty;
        uint256 bRoyalty;
        uint256 aRoyalty;
        uint256 distribution;
        if (_ref != address(0)) {
            refRoyalty = totalAmount * _referralPercent / 100;
            IAVOERC20(avoERC20Contract).safeTransfer(_ref, refRoyalty);
        }
        if (_tokens[_id].broker != address(0) && _tokens[_id].brokerRoyalty > 0) {
            bRoyalty = totalAmount * _tokens[_id].brokerRoyalty / 100;
            IAVOERC20(avoERC20Contract).safeTransfer(_tokens[_id].broker, bRoyalty);
        }
        if (_tokens[_id].authorRoyalty > 0) {
            aRoyalty = totalAmount * _tokens[_id].authorRoyalty / 100;
            IAVOERC20(avoERC20Contract).safeTransfer(_authors[_tokens[_id].authorID].wallet, aRoyalty);
        }
        if (_tokens[_id].platformRoyalty > 0) {
            pRoyalty = totalAmount * _tokens[_id].platformRoyalty / 100;
            distribution = pRoyalty * _communityDistributionPercent / 100;
            if (distribution > 0) {
                IAVOERC20(avoERC20Contract).safeApprove(avoERC20Contract, distribution);
                IAVOERC20(avoERC20Contract).addReward(distribution);
            }
            IAVOERC20(avoERC20Contract).safeTransfer(owner(), pRoyalty - distribution);
        }
        IAVOERC20(avoERC20Contract).safeTransfer(_owner, totalAmount - refRoyalty - pRoyalty - bRoyalty - aRoyalty);
    }


    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165, ERC1155Receiver) returns (bool) {
        return
            interfaceId == type(IERC1155Receiver).interfaceId ||
            interfaceId == type(IERC1155).interfaceId ||
            interfaceId == type(IERC1155MetadataURI).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), "ERC1155: balance query for the zero address");
        return _balances[id][account];
    }

    function balanceOfBatch(address account, uint256[] memory ids)
        public
        view
        virtual
        override
        returns (uint256[] memory)
    {
        require(ids.length > 0, "ERC1155: No ids provided");

        uint256[] memory batchBalances = new uint256[](ids.length);

        for (uint256 i = 0; i < ids.length; ++i) {
            batchBalances[i] = balanceOf(account, ids[i]);
        }

        return batchBalances;
    }


    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(_msgSender() != operator, "ERC1155: setting approval status for self");

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }


    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[account][operator];
    }


    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public  override {
        require((from == _msgSender() || isApprovedForAll(from, _msgSender()) || _tokenApprovals[from][_msgSender()][id] >= amount),
            "ERC1155: caller is not owner nor approved");
        _safeTransferFrom(from, to, id, amount, data);
        _tokenApprovals[from][_msgSender()][id] -= amount;
    }


    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            "ERC1155: transfer caller is not owner nor approved"
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }


    function _safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) internal virtual {
        require(to != address(0), "ERC1155: transfer to the zero address");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);

        uint256 fromBalance = _balances[id][from];
        require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");
        unchecked {
            _balances[id][from] = fromBalance - amount;
        }
        _balances[id][to] += amount;

        emit TransferSingle(operator, from, to, id, amount);

        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);
    }


    function _safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual {
        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");
        require(to != address(0), "ERC1155: transfer to the zero address");
        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, to, ids, amounts, data);

        for (uint256 i = 0; i < ids.length; ++i) {
            uint256 id = ids[i];
            uint256 amount = amounts[i];
            require(_tokenApprovals[from][operator][id] >= amount, "Amount exceeds approved");
            uint256 fromBalance = _balances[id][from];
            require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");
            unchecked {
                _balances[id][from] = fromBalance - amount;
            }
            _balances[id][to] += amount;
            _tokenApprovals[from][operator][id] -= amount;
        }

        emit TransferBatch(operator, from, to, ids, amounts);

        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);
    }


    function _mint(
        address account,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) internal virtual {
        require(account != address(0), "ERC1155: mint to the zero address");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);

        _balances[id][account] += amount;
        emit TransferSingle(operator, address(0), account, id, amount);

        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);
    }


    function burn(
        uint256 id,
        uint256 amount
    ) public {
        require(exists(id), "Token doesn't exist");
        require(amount > 0, "ERC1155: amount must exceed zero");
        require(amount <= _tokens[id].tokenSupply, "ERC1155: amount cannot exceed total supply");
        _burn(_msgSender(), id, amount);
        _tokens[id].tokenSupply -= amount;
    }



    function _burn(
        address account,
        uint256 id,
        uint256 amount
    ) internal virtual {
        require(account != address(0), "ERC1155: burn from the zero address");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), "");

        uint256 accountBalance = _balances[id][account];
        require(accountBalance >= amount, "ERC1155: burn amount exceeds balance");
        unchecked {
            _balances[id][account] = accountBalance - amount;
        }

        emit TransferSingle(operator, account, address(0), id, amount);
    }


    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual {}


    function _doSafeTransferAcceptanceCheck(
        address operator,
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) private {
        if (to.isContract()) {
            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {
                if (response != IERC1155Receiver(to).onERC1155Received.selector) {
                    revert("ERC1155: ERC1155Receiver rejected tokens");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert("ERC1155: transfer to non ERC1155Receiver implementer");
            }
        }
    }

    function _doSafeBatchTransferAcceptanceCheck(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) private {
        if (to.isContract()) {
            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (
                bytes4 response
            ) {
                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {
                    revert("ERC1155: ERC1155Receiver rejected tokens");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert("ERC1155: transfer to non ERC1155Receiver implementer");
            }
        }
    }

    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {
        uint256[] memory array = new uint256[](1);
        array[0] = element;

        return array;
    }

    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155Received.selector;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] memory,
        uint256[] memory,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155BatchReceived.selector;
    }

}